-- Demontime (Linoria lib version) 

-----------<WorldViusal LOCALS>

local IronColor = Color3.new(1, 1, 1)
local StoneColor = Color3.new(1, 1, 1)
local NitrateColor = Color3.new(1, 1, 1)
local PartBoxColor = Color3.new(1, 1, 1)
local VendingMachineColor = Color3.new(1, 1, 1)
local MetalCrateColor = Color3.new(1, 1, 1)
local ClaimTotemColor = Color3.new(1, 1, 1)
local RespawnTotemColor = Color3.new(1, 1, 1)
local SmallBoxColor = Color3.new(1, 1, 1)
local MediumBoxColor = Color3.new(1, 1, 1)
local CabinetColor = Color3.new(1, 1, 1)
local maxDistance = 500

-----------<WorldViusal LOCALS>

-----------------------------------<ORESBLABLABLABLAORES>--------------------------------

local TCESPs = {}
local adorned = false

local function calculateDistance(part)
    local camera = game.Workspace.CurrentCamera
    if camera and camera:IsA("Camera") then
        local cameraPosition = camera.CFrame.Position
        local partPosition = part.Position
        return (cameraPosition - partPosition).Magnitude
    end
    return math.huge -- Return a very large value if the camera is not available
end

local function addAdornments()
    local parts = workspace:GetDescendants()
    local partsToRemove = {} -- Store parts to remove ESPs from
    for _, part in ipairs(parts) do
        if part:IsA("MeshPart") and part.BrickColor == BrickColor.new("Burlap") and part.Material == Enum.Material.Slate then
            local parent = part.Parent
            if parent and parent:IsA("Model") and #parent:GetChildren() == 2 then
                local distance = calculateDistance(part)
                if distance <= maxDistance then
                    local isAdorned = false
                    for _, billboardGui in ipairs(TCESPs) do
                        if billboardGui.Adornee == part then
                            isAdorned = true
                            break
                        end
                    end
                    if not isAdorned then
                        local billboardGui = Instance.new("BillboardGui")
                        billboardGui.Size = UDim2.new(0, 100, 0, 50) -- Adjust the size as needed
                        billboardGui.AlwaysOnTop = true
                        billboardGui.StudsOffset = Vector3.new(0, 2, 0) -- Adjust the offset as needed
                        billboardGui.Adornee = part
                        billboardGui.Parent = part

                        local textLabel = Instance.new("TextLabel")
                        textLabel.Size = UDim2.new(1, 0, 1, 0)
                        textLabel.BackgroundTransparency = 1
                        textLabel.Text = "[Iron Ore]" -- Replace with the desired text
                        textLabel.Font = Enum.Font.SourceSans
                        textLabel.TextColor3 = IronColor
                        textLabel.TextSize = 15 -- Set the text size to 15
                        textLabel.Parent = billboardGui

                        table.insert(TCESPs, billboardGui)
                    end
                else
                    table.insert(partsToRemove, part)
                end
            end
        end
    end
    for _, partToRemove in ipairs(partsToRemove) do
        for i, billboardGui in ipairs(TCESPs) do
            if billboardGui.Adornee == partToRemove then
                billboardGui:Destroy()
                table.remove(TCESPs, i)
                break
            end
        end
    end
end

local function IronToggleAdornments()
    adorned = not adorned
    if adorned then
        addAdornments()
    else
        for _, billboardGui in ipairs(TCESPs) do
            billboardGui:Destroy()
        end
        TCESPs = {}
    end
end

game:GetService("RunService").Heartbeat:Connect(function()
    if adorned then
        addAdornments()
    end
end)

game:GetService("Workspace").ChildAdded:Connect(function(child)
    if adorned and child:IsA("MeshPart") and child.BrickColor == BrickColor.new("Burlap") and child.Material == Enum.Material.Slate then
        addAdornments()
    end
end)

game:GetService("Workspace").ChildRemoved:Connect(function(child)
    if adorned and child:IsA("MeshPart") and child.BrickColor == BrickColor.new("Burlap") and child.Material == Enum.Material.Slate then
        for i, billboardGui in ipairs(TCESPs) do
            if billboardGui.Adornee == child then
                billboardGui:Destroy()
                table.remove(TCESPs, i)
                break
            end
        end
    end
end)



------------------------------------------------------------------------------------[][][][][]

local TCESPs = {}
local adorned = false

local function calculateDistance(part)
    local camera = game.Workspace.CurrentCamera
    if camera and camera:IsA("Camera") then
        local cameraPosition = camera.CFrame.Position
        local partPosition = part.Position
        return (cameraPosition - partPosition).Magnitude
    end
    return math.huge -- Return a very large value if the camera is not available
end

local function addAdornments()
    local parts = workspace:GetDescendants()
    local partsToRemove = {} -- Store parts to remove ESPs from
    for _, part in ipairs(parts) do
        if part:IsA("MeshPart") and part.BrickColor == BrickColor.new("Flint") and part.Material == Enum.Material.Limestone then
            local parent = part.Parent
            if parent and parent:IsA("Model") and #parent:GetChildren() == 1 then
                local distance = calculateDistance(part)
                if distance <= maxDistance then
                    local isAdorned = false
                    for _, billboardGui in ipairs(TCESPs) do
                        if billboardGui.Adornee == part then
                            isAdorned = true
                            break
                        end
                    end
                    if not isAdorned then
                        local billboardGui = Instance.new("BillboardGui")
                        billboardGui.Size = UDim2.new(0, 100, 0, 50) -- Adjust the size as needed
                        billboardGui.AlwaysOnTop = true
                        billboardGui.StudsOffset = Vector3.new(0, 2, 0) -- Adjust the offset as needed
                        billboardGui.Adornee = part
                        billboardGui.Parent = part

                        local textLabel = Instance.new("TextLabel")
                        textLabel.Size = UDim2.new(1, 0, 1, 0)
                        textLabel.BackgroundTransparency = 1
                        textLabel.Text = "[Stone Ore]" -- Replace with the desired text
                        textLabel.Font = Enum.Font.SourceSans
                        textLabel.TextColor3 = StoneColor
                        textLabel.TextSize = 15 -- Set the text size to 15
                        textLabel.Parent = billboardGui

                        table.insert(TCESPs, billboardGui)
                    end
                else
                    table.insert(partsToRemove, part)
                end
            end
        end
    end
    for _, partToRemove in ipairs(partsToRemove) do
        for i, billboardGui in ipairs(TCESPs) do
            if billboardGui.Adornee == partToRemove then
                billboardGui:Destroy()
                table.remove(TCESPs, i)
                break
            end
        end
    end
end

local function StonetoggleAdornments()
    adorned = not adorned
    if adorned then
        addAdornments()
    else
        for _, billboardGui in ipairs(TCESPs) do
            billboardGui:Destroy()
        end
        TCESPs = {}
    end
end

game:GetService("RunService").Heartbeat:Connect(function()
    if adorned then
        addAdornments()
    end
end)

game:GetService("Workspace").ChildAdded:Connect(function(child)
    if adorned and child:IsA("MeshPart") and child.BrickColor == BrickColor.new("Flint") and child.Material == Enum.Material.Limestone then
        addAdornments()
    end
end)

game:GetService("Workspace").ChildRemoved:Connect(function(child)
    if adorned and child:IsA("MeshPart") and child.BrickColor == BrickColor.new("Flint") and child.Material == Enum.Material.Limestone then
        for i, billboardGui in ipairs(TCESPs) do
            if billboardGui.Adornee == child then
                billboardGui:Destroy()
                table.remove(TCESPs, i)
                break
            end
        end
    end
end)


------------------------------------------------------------------------------------[][][][][]

local TCESPs = {}
local adorned = false

local function calculateDistance(part)
    local camera = game.Workspace.CurrentCamera
    if camera and camera:IsA("Camera") then
        local cameraPosition = camera.CFrame.Position
        local partPosition = part.Position
        return (cameraPosition - partPosition).Magnitude
    end
    return math.huge -- Return a very large value if the camera is not available
end

local function addAdornments()
    local parts = workspace:GetDescendants()
    local partsToRemove = {} -- Store parts to remove ESPs from
    for _, part in ipairs(parts) do
        if part:IsA("MeshPart") and part.BrickColor == BrickColor.new("Institutional white") and part.Material == Enum.Material.Slate then
            local parent = part.Parent
            if parent and parent:IsA("Model") and #parent:GetChildren() > 0 then
                local distance = calculateDistance(part)
                if distance <= maxDistance then
                    local isAdorned = false
                    for _, billboardGui in ipairs(TCESPs) do
                        if billboardGui.Adornee == part then
                            isAdorned = true
                            break
                        end
                    end
                    if not isAdorned then
                        local billboardGui = Instance.new("BillboardGui")
                        billboardGui.Size = UDim2.new(0, 100, 0, 50) -- Adjust the size as needed
                        billboardGui.AlwaysOnTop = true
                        billboardGui.StudsOffset = Vector3.new(0, 2, 0) -- Adjust the offset as needed
                        billboardGui.Adornee = part
                        billboardGui.Parent = part

                        local textLabel = Instance.new("TextLabel")
                        textLabel.Size = UDim2.new(1, 0, 1, 0)
                        textLabel.BackgroundTransparency = 1
                        textLabel.Text = "[Nitrate Ore]" -- Replace with the desired text
                        textLabel.Font = Enum.Font.SourceSans
                        textLabel.TextColor3 = NitrateColor
                        textLabel.TextSize = 15 -- Set the text size to 15
                        textLabel.Parent = billboardGui

                        table.insert(TCESPs, billboardGui)
                    end
                else
                    table.insert(partsToRemove, part)
                end
            end
        end
    end
    for _, partToRemove in ipairs(partsToRemove) do
        for i, billboardGui in ipairs(TCESPs) do
            if billboardGui.Adornee == partToRemove then
                billboardGui:Destroy()
                table.remove(TCESPs, i)
                break
            end
        end
    end
end

local function NitratetoggleAdornments()
    adorned = not adorned
    if adorned then
        addAdornments()
    else
        for _, billboardGui in ipairs(TCESPs) do
            billboardGui:Destroy()
        end
        TCESPs = {}
    end
end

game:GetService("RunService").Heartbeat:Connect(function()
    if adorned then
        addAdornments()
    end
end)

game:GetService("Workspace").ChildAdded:Connect(function(child)
    if adorned and child:IsA("MeshPart") and child.BrickColor == BrickColor.new("Institutional white") and child.Material == Enum.Material.Slate then
        addAdornments()
    end
end)

game:GetService("Workspace").ChildRemoved:Connect(function(child)
    if adorned and child:IsA("MeshPart") and child.BrickColor == BrickColor.new("Institutional white") and child.Material == Enum.Material.Slate then
        for i, billboardGui in ipairs(TCESPs) do
            if billboardGui.Adornee == child then
                billboardGui:Destroy()
                table.remove(TCESPs, i)
                break
            end
        end
    end
end)


------------------------------------------------------------------------------------[][][][][]

local TCESPs = {}
local adorned = false

local function calculateDistance(part)
    local camera = game.Workspace.CurrentCamera
    if camera and camera:IsA("Camera") then
        local cameraPosition = camera.CFrame.Position
        local partPosition = part.Position
        return (cameraPosition - partPosition).Magnitude
    end
    return math.huge -- Return a very large value if the camera is not available
end

local function addAdornments()
    local parts = workspace:GetDescendants()
    local partsToRemove = {} -- Store parts to remove ESPs from
    for _, part in ipairs(parts) do
        if part:IsA("UnionOperation") and part.BrickColor == BrickColor.new("Cashmere") and part.Material == Enum.Material.Plastic then
            local parent = part.Parent
            if parent and parent:IsA("Model") and #parent:GetChildren() == 2 then
                local distance = calculateDistance(part)
                if distance <= maxDistance then
                    local isAdorned = false
                    for _, billboardGui in ipairs(TCESPs) do
                        if billboardGui.Adornee == part then
                            isAdorned = true
                            break
                        end
                    end
                    if not isAdorned then
                        local billboardGui = Instance.new("BillboardGui")
                        billboardGui.Size = UDim2.new(0, 100, 0, 50) -- Adjust the size as needed
                        billboardGui.AlwaysOnTop = true
                        billboardGui.StudsOffset = Vector3.new(0, 2, 0) -- Adjust the offset as needed
                        billboardGui.Adornee = part
                        billboardGui.Parent = part

                        local textLabel = Instance.new("TextLabel")
                        textLabel.Size = UDim2.new(1, 0, 1, 0)
                        textLabel.BackgroundTransparency = 1
                        textLabel.Text = "[Part Box]" -- Replace with the desired text
                        textLabel.Font = Enum.Font.SourceSans
                        textLabel.TextColor3 = PartBoxColor
                        textLabel.TextSize = 15 -- Set the text size to 15
                        textLabel.Parent = billboardGui

                        table.insert(TCESPs, billboardGui)
                    end
                else
                    table.insert(partsToRemove, part)
                end
            end
        end
    end
    for _, partToRemove in ipairs(partsToRemove) do
        for i, billboardGui in ipairs(TCESPs) do
            if billboardGui.Adornee == partToRemove then
                billboardGui:Destroy()
                table.remove(TCESPs, i)
                break
            end
        end
    end
end

local function PartBoxtoggleAdornments()
    adorned = not adorned
    if adorned then
        addAdornments()
    else
        for _, billboardGui in ipairs(TCESPs) do
            billboardGui:Destroy()
        end
        TCESPs = {}
    end
end

game:GetService("RunService").Heartbeat:Connect(function()
    if adorned then
        addAdornments()
    end
end)

game:GetService("Workspace").ChildAdded:Connect(function(child)
    if adorned and child:IsA("UnionOperation") and child.BrickColor == BrickColor.new("Cashmere") and child.Material == Enum.Material.Plastic then
        addAdornments()
    end
end)

game:GetService("Workspace").ChildRemoved:Connect(function(child)
    if adorned and child:IsA("UnionOperation") and child.BrickColor == BrickColor.new("Cashmere") and child.Material == Enum.Material.Plastic then
        for i, billboardGui in ipairs(TCESPs) do
            if billboardGui.Adornee == child then
                billboardGui:Destroy()
                table.remove(TCESPs, i)
                break
            end
        end
    end
end)


------------------------------------------------------------------------------------[][][][][]

local TCESPs = {}
local adorned = false

local function calculateDistance(part)
    local camera = game.Workspace.CurrentCamera
    if camera and camera:IsA("Camera") then
        local cameraPosition = camera.CFrame.Position
        local partPosition = part.Position
        return (cameraPosition - partPosition).Magnitude
    end
    return math.huge -- Return a very large value if the camera is not available
end

local function addAdornments()
    local parts = workspace:GetDescendants()
    local partsToRemove = {} -- Store parts to remove ESPs from
    for _, part in ipairs(parts) do
        if part:IsA("UnionOperation") and part.BrickColor == BrickColor.new("Medium brown") and part.Material == Enum.Material.Plastic then
            local parent = part.Parent
            if parent and parent:IsA("Model") and #parent:GetChildren() == 12 then
                local distance = calculateDistance(part)
                if distance <= maxDistance then
                    local isAdorned = false
                    for _, billboardGui in ipairs(TCESPs) do
                        if billboardGui.Adornee == part then
                            isAdorned = true
                            break
                        end
                    end
                    if not isAdorned then
                        local billboardGui = Instance.new("BillboardGui")
                        billboardGui.Size = UDim2.new(0, 100, 0, 50) -- Adjust the size as needed
                        billboardGui.AlwaysOnTop = true
                        billboardGui.StudsOffset = Vector3.new(0, 2, 0) -- Adjust the offset as needed
                        billboardGui.Adornee = part
                        billboardGui.Parent = part

                        local textLabel = Instance.new("TextLabel")
                        textLabel.Size = UDim2.new(1, 0, 1, 0)
                        textLabel.BackgroundTransparency = 1
                        textLabel.Text = "[Vending Machine]" -- Replace with the desired text
                        textLabel.Font = Enum.Font.SourceSans
                        textLabel.TextColor3 = VendingMachineColor
                        textLabel.TextSize = 15 -- Set the text size to 15
                        textLabel.Parent = billboardGui

                        table.insert(TCESPs, billboardGui)
                    end
                else
                    table.insert(partsToRemove, part)
                end
            end
        end
    end
    for _, partToRemove in ipairs(partsToRemove) do
        for i, billboardGui in ipairs(TCESPs) do
            if billboardGui.Adornee == partToRemove then
                billboardGui:Destroy()
                table.remove(TCESPs, i)
                break
            end
        end
    end
end

local function VendingMachinetoggleAdornments()
    adorned = not adorned
    if adorned then
        addAdornments()
    else
        for _, billboardGui in ipairs(TCESPs) do
            billboardGui:Destroy()
        end
        TCESPs = {}
    end
end

game:GetService("RunService").Heartbeat:Connect(function()
    if adorned then
        addAdornments()
    end
end)

game:GetService("Workspace").ChildAdded:Connect(function(child)
    if adorned and child:IsA("UnionOperation") and child.BrickColor == BrickColor.new("Medium brown") and child.Material == Enum.Material.Plastic then
        addAdornments()
    end
end)

game:GetService("Workspace").ChildRemoved:Connect(function(child)
    if adorned and child:IsA("UnionOperation") and child.BrickColor == BrickColor.new("Medium brown") and child.Material == Enum.Material.Plastic then
        for i, billboardGui in ipairs(TCESPs) do
            if billboardGui.Adornee == child then
                billboardGui:Destroy()
                table.remove(TCESPs, i)
                break
            end
        end
    end
end)


------------------------------------------------------------------------------------[][][][][]

local TCESPs = {}
local adorned = false

local function calculateDistance(part)
    local camera = game.Workspace.CurrentCamera
    if camera and camera:IsA("Camera") then
        local cameraPosition = camera.CFrame.Position
        local partPosition = part.Position
        return (cameraPosition - partPosition).Magnitude
    end
    return math.huge -- Return a very large value if the camera is not available
end

local function addAdornments()
    local parts = workspace:GetDescendants()
    local partsToRemove = {} -- Store parts to remove ESPs from
    for _, part in ipairs(parts) do
        if part:IsA("MeshPart") and part.BrickColor == BrickColor.new("Silver flip/flop") and part.Material == Enum.Material.Metal then
            local parent = part.Parent
            if parent and parent:IsA("Model") and #parent:GetChildren() == 2 then
                local distance = calculateDistance(part)
                if distance <= maxDistance then
                    local isAdorned = false
                    for _, billboardGui in ipairs(TCESPs) do
                        if billboardGui.Adornee == part then
                            isAdorned = true
                            break
                        end
                    end
                    if not isAdorned then
                        local billboardGui = Instance.new("BillboardGui")
                        billboardGui.Size = UDim2.new(0, 100, 0, 50) -- Adjust the size as needed
                        billboardGui.AlwaysOnTop = true
                        billboardGui.StudsOffset = Vector3.new(0, 2, 0) -- Adjust the offset as needed
                        billboardGui.Adornee = part
                        billboardGui.Parent = part

                        local textLabel = Instance.new("TextLabel")
                        textLabel.Size = UDim2.new(1, 0, 1, 0)
                        textLabel.BackgroundTransparency = 1
                        textLabel.Text = "[Military Crate]" -- Replace with the desired text
                        textLabel.Font = Enum.Font.SourceSans
                        textLabel.TextColor3 = MetalCrateColor
                        textLabel.TextSize = 15 -- Set the text size to 15
                        textLabel.Parent = billboardGui

                        table.insert(TCESPs, billboardGui)
                    end
                else
                    table.insert(partsToRemove, part)
                end
            end
        end
    end
    for _, partToRemove in ipairs(partsToRemove) do
        for i, billboardGui in ipairs(TCESPs) do
            if billboardGui.Adornee == partToRemove then
                billboardGui:Destroy()
                table.remove(TCESPs, i)
                break
            end
        end
    end
end

local function MetalCratetoggleAdornments()
    adorned = not adorned
    if adorned then
        addAdornments()
    else
        for _, billboardGui in ipairs(TCESPs) do
            billboardGui:Destroy()
        end
        TCESPs = {}
    end
end

game:GetService("RunService").Heartbeat:Connect(function()
    if adorned then
        addAdornments()
    end
end)

game:GetService("Workspace").ChildAdded:Connect(function(child)
    if adorned and child:IsA("MeshPart") and child.BrickColor == BrickColor.new("Silver flip/flop") and child.Material == Enum.Material.Metal then
        addAdornments()
    end
end)

game:GetService("Workspace").ChildRemoved:Connect(function(child)
    if adorned and child:IsA("MeshPart") and child.BrickColor == BrickColor.new("Silver flip/flop") and child.Material == Enum.Material.Metal then
        for i, billboardGui in ipairs(TCESPs) do
            if billboardGui.Adornee == child then
                billboardGui:Destroy()
                table.remove(TCESPs, i)
                break
            end
        end
    end
end)


------------------------------------------------------------------------------------[][][][][]

local TCESPs = {}
local adorned = false

local function calculateDistance(part)
    local camera = game.Workspace.CurrentCamera
    if camera and camera:IsA("Camera") then
        local cameraPosition = camera.CFrame.Position
        local partPosition = part.Position
        return (cameraPosition - partPosition).Magnitude
    end
    return math.huge -- Return a very large value if the camera is not available
end

local function addAdornments()
    local parts = workspace:GetDescendants()
    local partsToRemove = {} -- Store parts to remove ESPs from
    for _, part in ipairs(parts) do
        if part:IsA("Part") and part.BrickColor == BrickColor.new("Dark blue") and part.Material == Enum.Material.Neon then
            local parent = part.Parent
            if parent and parent:IsA("Model") and #parent:GetChildren() == 5 then
                local distance = calculateDistance(part)
                if distance <= maxDistance then
                    local isAdorned = false
                    for _, billboardGui in ipairs(TCESPs) do
                        if billboardGui.Adornee == part then
                            isAdorned = true
                            break
                        end
                    end
                    if not isAdorned then
                        local billboardGui = Instance.new("BillboardGui")
                        billboardGui.Size = UDim2.new(0, 100, 0, 50) -- Adjust the size as needed
                        billboardGui.AlwaysOnTop = true
                        billboardGui.StudsOffset = Vector3.new(0, 2, 0) -- Adjust the offset as needed
                        billboardGui.Adornee = part
                        billboardGui.Parent = part

                        local textLabel = Instance.new("TextLabel")
                        textLabel.Size = UDim2.new(1, 0, 1, 0)
                        textLabel.BackgroundTransparency = 1
                        textLabel.Text = "[Claim Totem]" -- Replace with the desired text
                        textLabel.Font = Enum.Font.SourceSans
                        textLabel.TextColor3 = ClaimTotemColor
                        textLabel.TextSize = 15 -- Set the text size to 15
                        textLabel.Parent = billboardGui

                        table.insert(TCESPs, billboardGui)
                    end
                else
                    table.insert(partsToRemove, part)
                end
            end
        end
    end
    for _, partToRemove in ipairs(partsToRemove) do
        for i, billboardGui in ipairs(TCESPs) do
            if billboardGui.Adornee == partToRemove then
                billboardGui:Destroy()
                table.remove(TCESPs, i)
                break
            end
        end
    end
end

local function ClaimTotemtoggleAdornments()
    adorned = not adorned
    if adorned then
        addAdornments()
    else
        for _, billboardGui in ipairs(TCESPs) do
            billboardGui:Destroy()
        end
        TCESPs = {}
    end
end

game:GetService("RunService").Heartbeat:Connect(function()
    if adorned then
        addAdornments()
    end
end)

game:GetService("Workspace").ChildAdded:Connect(function(child)
    if adorned and child:IsA("Part") and child.BrickColor == BrickColor.new("Dark blue") and child.Material == Enum.Material.Neon then
        addAdornments()
    end
end)

game:GetService("Workspace").ChildRemoved:Connect(function(child)
    if adorned and child:IsA("Part") and child.BrickColor == BrickColor.new("Dark blue") and child.Material == Enum.Material.Neon then
        for i, billboardGui in ipairs(TCESPs) do
            if billboardGui.Adornee == child then
                billboardGui:Destroy()
                table.remove(TCESPs, i)
                break
            end
        end
    end
end)


------------------------------------------------------------------------------------[][][][][]

local TCESPs = {}
local adorned = false

local function calculateDistance(part)
    local camera = game.Workspace.CurrentCamera
    if camera and camera:IsA("Camera") then
        local cameraPosition = camera.CFrame.Position
        local partPosition = part.Position
        return (cameraPosition - partPosition).Magnitude
    end
    return math.huge -- Return a very large value if the camera is not available
end

local function addAdornments()
    local parts = workspace:GetDescendants()
    local partsToRemove = {} -- Store parts to remove ESPs from
    for _, part in ipairs(parts) do
        if part:IsA("Part") and part.BrickColor == BrickColor.new("Gun metallic") and part.Material == Enum.Material.Wood then
            local parent = part.Parent
            if parent and parent:IsA("Model") and #parent:GetChildren() == 10 then
                local distance = calculateDistance(part)
                if distance <= maxDistance then
                    local isAdorned = false
                    for _, billboardGui in ipairs(TCESPs) do
                        if billboardGui.Adornee == part then
                            isAdorned = true
                            break
                        end
                    end
                    if not isAdorned then
                        local billboardGui = Instance.new("BillboardGui")
                        billboardGui.Size = UDim2.new(0, 100, 0, 50) -- Adjust the size as needed
                        billboardGui.AlwaysOnTop = true
                        billboardGui.StudsOffset = Vector3.new(0, 2, 0) -- Adjust the offset as needed
                        billboardGui.Adornee = part
                        billboardGui.Parent = part

                        local textLabel = Instance.new("TextLabel")
                        textLabel.Size = UDim2.new(1, 0, 1, 0)
                        textLabel.BackgroundTransparency = 1
                        textLabel.Text = "[Cabinet]" -- Replace with the desired text
                        textLabel.Font = Enum.Font.SourceSans
                        textLabel.TextColor3 = CabinetColor
                        textLabel.TextSize = 15 -- Set the text size to 15
                        textLabel.Parent = billboardGui

                        table.insert(TCESPs, billboardGui)
                    end
                else
                    table.insert(partsToRemove, part)
                end
            end
        end
    end
    for _, partToRemove in ipairs(partsToRemove) do
        for i, billboardGui in ipairs(TCESPs) do
            if billboardGui.Adornee == partToRemove then
                billboardGui:Destroy()
                table.remove(TCESPs, i)
                break
            end
        end
    end
end

local function CabinettoggleAdornments()
    adorned = not adorned
    if adorned then
        addAdornments()
    else
        for _, billboardGui in ipairs(TCESPs) do
            billboardGui:Destroy()
        end
        TCESPs = {}
    end
end

game:GetService("RunService").Heartbeat:Connect(function()
    if adorned then
        addAdornments()
    end
end)

game:GetService("Workspace").ChildAdded:Connect(function(child)
    if adorned and child:IsA("Part") and child.BrickColor == BrickColor.new("Gun metallic") and child.Material == Enum.Material.Wood then
        addAdornments()
    end
end)

game:GetService("Workspace").ChildRemoved:Connect(function(child)
    if adorned and child:IsA("Part") and child.BrickColor == BrickColor.new("Gun metallic") and child.Material == Enum.Material.Wood then
        for i, billboardGui in ipairs(TCESPs) do
            if billboardGui.Adornee == child then
                billboardGui:Destroy()
                table.remove(TCESPs, i)
                break
            end
        end
    end
end)


------------------------------------------------------------------------------------[][][][][]

local TCESPs = {}
local adorned = false

local function calculateDistance(part)
    local camera = game.Workspace.CurrentCamera
    if camera and camera:IsA("Camera") then
        local cameraPosition = camera.CFrame.Position
        local partPosition = part.Position
        return (cameraPosition - partPosition).Magnitude
    end
    return math.huge -- Return a very large value if the camera is not available
end

local function addAdornments()
    local parts = workspace:GetDescendants()
    local partsToRemove = {} -- Store parts to remove ESPs from
    for _, part in ipairs(parts) do
        if part:IsA("Part") and part.BrickColor == BrickColor.new("Dark stone grey") and part.Material == Enum.Material.Slate then
            local parent = part.Parent
            if parent and parent:IsA("Model") and #parent:GetChildren() == 4 then
                local distance = calculateDistance(part)
                if distance <= maxDistance then
                    local isAdorned = false
                    for _, billboardGui in ipairs(TCESPs) do
                        if billboardGui.Adornee == part then
                            isAdorned = true
                            break
                        end
                    end
                    if not isAdorned then
                        local billboardGui = Instance.new("BillboardGui")
                        billboardGui.Size = UDim2.new(0, 100, 0, 50) -- Adjust the size as needed
                        billboardGui.AlwaysOnTop = true
                        billboardGui.StudsOffset = Vector3.new(0, 2, 0) -- Adjust the offset as needed
                        billboardGui.Adornee = part
                        billboardGui.Parent = part

                        local textLabel = Instance.new("TextLabel")
                        textLabel.Size = UDim2.new(1, 0, 1, 0)
                        textLabel.BackgroundTransparency = 1
                        textLabel.Text = "[Respawn Totem]" -- Replace with the desired text
                        textLabel.Font = Enum.Font.SourceSans
                        textLabel.TextColor3 = RespawnTotemColor
                        textLabel.TextSize = 15 -- Set the text size to 15
                        textLabel.Parent = billboardGui

                        table.insert(TCESPs, billboardGui)
                    end
                else
                    table.insert(partsToRemove, part)
                end
            end
        end
    end
    for _, partToRemove in ipairs(partsToRemove) do
        for i, billboardGui in ipairs(TCESPs) do
            if billboardGui.Adornee == partToRemove then
                billboardGui:Destroy()
                table.remove(TCESPs, i)
                break
            end
        end
    end
end

local function RespawnTotemtoggleAdornments()
    adorned = not adorned
    if adorned then
        addAdornments()
    else
        for _, billboardGui in ipairs(TCESPs) do
            billboardGui:Destroy()
        end
        TCESPs = {}
    end
end

game:GetService("RunService").Heartbeat:Connect(function()
    if adorned then
        addAdornments()
    end
end)

game:GetService("Workspace").ChildAdded:Connect(function(child)
    if adorned and child:IsA("Part") and child.BrickColor == BrickColor.new("Dark stone grey") and child.Material == Enum.Material.Slate then
        addAdornments()
    end
end)

game:GetService("Workspace").ChildRemoved:Connect(function(child)
    if adorned and child:IsA("Part") and child.BrickColor == BrickColor.new("Dark stone grey") and child.Material == Enum.Material.Slate then
        for i, billboardGui in ipairs(TCESPs) do
            if billboardGui.Adornee == child then
                billboardGui:Destroy()
                table.remove(TCESPs, i)
                break
            end
        end
    end
end)


------------------------------------------------------------------------------------[][][][][]

local TCESPs = {}
local adorned = false

local function calculateDistance(part)
    local camera = game.Workspace.CurrentCamera
    if camera and camera:IsA("Camera") then
        local cameraPosition = camera.CFrame.Position
        local partPosition = part.Position
        return (cameraPosition - partPosition).Magnitude
    end
    return math.huge -- Return a very large value if the camera is not available
end

local function addAdornments()
    local parts = workspace:GetDescendants()
    local partsToRemove = {} -- Store parts to remove ESPs from
    for _, part in ipairs(parts) do
        if part:IsA("Part") and part.BrickColor == BrickColor.new("Linen") and part.Material == Enum.Material.WoodPlanks and part.Size == Vector3.new(3.25, 2, 2.25) then
            local parent = part.Parent
            if parent and parent:IsA("Model") and #parent:GetChildren() == 3 then
                local distance = calculateDistance(part)
                if distance <= maxDistance then
                    local isAdorned = false
                    for _, billboardGui in ipairs(TCESPs) do
                        if billboardGui.Adornee == part then
                            isAdorned = true
                            break
                        end
                    end
                    if not isAdorned then
                        local billboardGui = Instance.new("BillboardGui")
                        billboardGui.Size = UDim2.new(0, 100, 0, 50) -- Adjust the size as needed
                        billboardGui.AlwaysOnTop = true
                        billboardGui.StudsOffset = Vector3.new(0, 2, 0) -- Adjust the offset as needed
                        billboardGui.Adornee = part
                        billboardGui.Parent = part

                        local textLabel = Instance.new("TextLabel")
                        textLabel.Size = UDim2.new(1, 0, 1, 0)
                        textLabel.BackgroundTransparency = 1
                        textLabel.Text = "[Small Box]" -- Replace with the desired text
                        textLabel.Font = Enum.Font.SourceSans
                        textLabel.TextColor3 = SmallBoxColor
                        textLabel.TextSize = 15 -- Set the text size to 15
                        textLabel.Parent = billboardGui

                        table.insert(TCESPs, billboardGui)
                    end
                else
                    table.insert(partsToRemove, part)
                end
            end
        end
    end
    for _, partToRemove in ipairs(partsToRemove) do
        for i, billboardGui in ipairs(TCESPs) do
            if billboardGui.Adornee == partToRemove then
                billboardGui:Destroy()
                table.remove(TCESPs, i)
                break
            end
        end
    end
end

local function SmallBoxtoggleAdornments()
    adorned = not adorned
    if adorned then
        addAdornments()
    else
        for _, billboardGui in ipairs(TCESPs) do
            billboardGui:Destroy()
        end
        TCESPs = {}
    end
end

game:GetService("RunService").Heartbeat:Connect(function()
    if adorned then
        addAdornments()
    end
end)

game:GetService("Workspace").ChildAdded:Connect(function(child)
    if adorned and child:IsA("Part") and child.BrickColor == BrickColor.new("Linen") and child.Material == Enum.Material.WoodPlanks and part.Size == Vector3.new(3.25, 2, 2.25) then
        addAdornments()
    end
end)

game:GetService("Workspace").ChildRemoved:Connect(function(child)
    if adorned and child:IsA("Part") and child.BrickColor == BrickColor.new("Linen") and child.Material == Enum.Material.WoodPlanks and part.Size == Vector3.new(3.25, 2, 2.25) then
        for i, billboardGui in ipairs(TCESPs) do
            if billboardGui.Adornee == child then
                billboardGui:Destroy()
                table.remove(TCESPs, i)
                break
            end
        end
    end
end)


------------------------------------------------------------------------------------[][][][][]

local TCESPs = {}
local adorned = false

local function calculateDistance(part)
    local camera = game.Workspace.CurrentCamera
    if camera and camera:IsA("Camera") then
        local cameraPosition = camera.CFrame.Position
        local partPosition = part.Position
        return (cameraPosition - partPosition).Magnitude
    end
    return math.huge -- Return a very large value if the camera is not available
end

local function addAdornments()
    local parts = workspace:GetDescendants()
    local partsToRemove = {} -- Store parts to remove ESPs from
    for _, part in ipairs(parts) do
        if part:IsA("Part") and part.BrickColor == BrickColor.new("Linen") and part.Material == Enum.Material.WoodPlanks and part.Size == Vector3.new(6, 2.5, 2.75) then
            local parent = part.Parent
            if parent and parent:IsA("Model") and #parent:GetChildren() == 3 then
                local distance = calculateDistance(part)
                if distance <= maxDistance then
                    local isAdorned = false
                    for _, billboardGui in ipairs(TCESPs) do
                        if billboardGui.Adornee == part then
                            isAdorned = true
                            break
                        end
                    end
                    if not isAdorned then
                        local billboardGui = Instance.new("BillboardGui")
                        billboardGui.Size = UDim2.new(0, 100, 0, 50) -- Adjust the size as needed
                        billboardGui.AlwaysOnTop = true
                        billboardGui.StudsOffset = Vector3.new(0, 2, 0) -- Adjust the offset as needed
                        billboardGui.Adornee = part
                        billboardGui.Parent = part

                        local textLabel = Instance.new("TextLabel")
                        textLabel.Size = UDim2.new(1, 0, 1, 0)
                        textLabel.BackgroundTransparency = 1
                        textLabel.Text = "[Medium Box]" -- Replace with the desired text
                        textLabel.Font = Enum.Font.SourceSans
                        textLabel.TextColor3 = MediumBoxColor
                        textLabel.TextSize = 15 -- Set the text size to 15
                        textLabel.Parent = billboardGui

                        table.insert(TCESPs, billboardGui)
                    end
                else
                    table.insert(partsToRemove, part)
                end
            end
        end
    end
    for _, partToRemove in ipairs(partsToRemove) do
        for i, billboardGui in ipairs(TCESPs) do
            if billboardGui.Adornee == partToRemove then
                billboardGui:Destroy()
                table.remove(TCESPs, i)
                break
            end
        end
    end
end

local function MediumBoxtoggleAdornments()
    adorned = not adorned
    if adorned then
        addAdornments()
    else
        for _, billboardGui in ipairs(TCESPs) do
            billboardGui:Destroy()
        end
        TCESPs = {}
    end
end

game:GetService("RunService").Heartbeat:Connect(function()
    if adorned then
        addAdornments()
    end
end)

game:GetService("Workspace").ChildAdded:Connect(function(child)
    if adorned and child:IsA("Part") and child.BrickColor == BrickColor.new("Linen") and child.Material == Enum.Material.WoodPlanks and part.Size == Vector3.new(6, 2.5, 2.75) then
        addAdornments()
    end
end)

game:GetService("Workspace").ChildRemoved:Connect(function(child)
    if adorned and child:IsA("Part") and child.BrickColor == BrickColor.new("Linen") and child.Material == Enum.Material.WoodPlanks and part.Size == Vector3.new(6, 2.5, 2.75) then
        for i, billboardGui in ipairs(TCESPs) do
            if billboardGui.Adornee == child then
                billboardGui:Destroy()
                table.remove(TCESPs, i)
                break
            end
        end
    end
end)


------------------------------------------------------------------------------------[][][][][]











local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'

local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

local Window = Library:CreateWindow({
    Title = 'THIS SCRIPT HAS AN IP LOGGING CODE',
    Center = true,
    AutoShow = true,
    TabPadding = 0,
    MenuFadeTime = 0
})





------// LPH >--------------------------------

function LPH_JIT_ULTRA(f)
	return f
	end
	function LPH_JIT_MAX(f)
	return f
	end  

	if not LPH_OBFUSCATED then
		LPH_JIT = function(...) return ... end
		LPH_JIT_MAX = function(...) return ... end
		LPH_JIT_ULTRA = function(...) return ... end
		LPH_NO_VIRTUALIZE = function(...) return ... end
		LPH_NO_UPVALUES = function(f) return(function(...) return f(...) end) end
		LPH_ENCSTR = function(...) return ... end
		LPH_STRENC = function(...) return ... end
		LPH_HOOK_FIX = function(...) return ... end
		LPH_CRASH = function() return print(debug.traceback()) end
	end

------// LPH >--------------------------------


    
--< Bypasses >--------------------------------
	
	local antihitbox
	antihitbox = hookmetamethod(game, "__index", LPH_NO_VIRTUALIZE(function(...)
	local self, k = ...
	if not checkcaller() and k == "Size" and self.Name == "Head" then
		return 1.672248125076294, 0.835624098777771, 0.835624098777771
	end
	return antihitbox(...)
	end))
	local antixray
	antixray = hookmetamethod(game, "__index", LPH_NO_VIRTUALIZE(function(...)
	local self, k = ...
	if not checkcaller() and k == "Hitbox" and self.Name == "Transparency" then
		return 1
	end
	return antixray(...)
	end))
	local mt = getrawmetatable(game)
	make_writeable(mt)
	local old_index = mt.__index
	mt.__index = function(a,b)
	if tostring(a) == "Workspace" then
		if tostring(b) == "Gravity" then
			return 75;
		end
	end
	return old_index(a, b)
end    

--< Bypasses >--------------------------------

	





local Tabs = {
    Main = Window:AddTab('Main'),
}

local TabBox = Tabs.Main:AddLeftTabbox()


-----------<HBE LOCALS>

local HeadExtends = false

local Radius = 6

local TargetOptions = {
    ["Head"] = "Head",
    ["Torso"] = "Torso",
}
local selectedTarget = TargetOptions["Head"]

local HBXColor = Color3.new(1, 1, 1)

local TargetMaterial = {
    ["Plastic"] = Enum.Material.Plastic, 
    ["Wood"] = Enum.Material.Wood,
    ["Slate"] = Enum.Material.Slate,
    ["Concrete"] = Enum.Material.Concrete,
    ["CorrodedMetal"] = Enum.Material.CorrodedMetal,
    ["DiamondPlate"] = Enum.Material.DiamondPlate,
    ["Foil"] = Enum.Material.Foil,
    ["Grass"] = Enum.Material.Grass,
    ["Ice"] = Enum.Material.Ice,
    ["Marble"] = Enum.Material.Marble,
    ["Granite"] = Enum.Material.Granite,
    ["Brick"] = Enum.Material.Brick,
    ["Pebble"] = Enum.Material.Pebble,
    ["Sand"] = Enum.Material.Sand,
    ["Fabric"] = Enum.Material.Fabric,
    ["SmoothPlastic"] = Enum.Material.SmoothPlastic,
    ["Metal"] = Enum.Material.Metal,
    ["WoodPlanks"] = Enum.Material.WoodPlanks,
    ["Neon"] = Enum.Material.Neon,
    ["Cobblestone"] = Enum.Material.Cobblestone,
    ["Glass"] = Enum.Material.Glass,
    ["Asphalt"] = Enum.Material.Asphalt,
    ["LeafyGrass"] = Enum.Material.LeafyGrass,
    ["Salt"] = Enum.Material.Salt,
    ["Limestone"] = Enum.Material.Limestone,
    ["Basalt"] = Enum.Material.Basalt,
    ["ForceField"] = Enum.Material.ForceField,
}
local selectedMaterial = TargetMaterial["ForceField"]

local TargetShape = {
    ["Ball"] = Enum.PartType.Ball, 
    ["Cube"] = Enum.PartType.Block,
    ["Cylinder"] = Enum.PartType.Cylinder,
}
local selectedShape = TargetShape["Ball"]

local HitboxTransparency = 0.5

local HBXH = false
local SizeX = 10
local SizeY = 10
local SizeZ = 10
local TransHead = 0
local ColorBRUH = Color3.fromRGB(80,77,56)

-----------<HBE LOCALS>

-----------<HBE Function>

local HedsOn = Instance.new("Part")
HedsOn.Name = "HedsOn"
HedsOn.Anchored = false
HedsOn.CanCollide = false
HedsOn.Transparency = HitboxTransparency
HedsOn.Color = HBXColor
HedsOn.Material = selectedMaterial
HedsOn.Size = Vector3.new(Radius * 2, Radius * 2, Radius * 2)  
HedsOn.Shape = selectedShape or Enum.PartType.Ball
HedsOn.Parent = game.ReplicatedStorage

task.spawn(function()
    while task.wait() do
        if HeadExtends then
            for _, i in ipairs(game:GetService("Workspace"):GetChildren()) do
                if i:FindFirstChild("HumanoidRootPart") and not i:FindFirstChild("HedsOn") then                        	
                    local BigHeadsPart = Instance.new("Part")
                    BigHeadsPart.Name = selectedTarget
                    BigHeadsPart.Anchored = false
                    BigHeadsPart.CanCollide = false
                    BigHeadsPart.Transparency = HitboxTransparency
                    BigHeadsPart.Size = Vector3.new(Radius * 2, Radius * 2, Radius * 2)
                    BigHeadsPart.Material = selectedMaterial or Enum.Material.ForceField
                    BigHeadsPart.Color = HBXColor
                    BigHeadsPart.Shape = selectedShape or Enum.PartType.Ball
                    
                
                    local DeletePart = Instance.new("Weld")
                    DeletePart.Parent = BigHeadsPart
                    DeletePart.Name = "FAKEHEAD"
                    
                    local HeadsParts = BigHeadsPart:Clone()
                    HeadsParts.Parent = i
                    HeadsParts.Orientation = i.HumanoidRootPart.Orientation
                    
                    local clonedHedsOn = HedsOn:Clone()
                    clonedHedsOn.Parent = i
                    
                    local Headswelding = Instance.new("Weld")
                    Headswelding.Parent = HeadsParts
                    Headswelding.Part0 = i.HumanoidRootPart
                    Headswelding.Part1 = HeadsParts
                    
                    HeadsParts.Position = i[selectedTarget].Position

                end
            end
        else
            for _, i in ipairs(game:GetService("Workspace"):GetChildren()) do
                if i:FindFirstChild("HumanoidRootPart") and i:FindFirstChild("HedsOn") then
                    i.HedsOn:Remove()
                    for _, a in ipairs(i:GetChildren()) do
                      if (selectedTarget == "Head" or selectedTarget == "Torso") and a.Name == selectedTarget and a:FindFirstChild("FAKEHEAD") and (not a:FindFirstChild("Nametag") or not a:FindFirstChild("Face")) then
                            a:Remove()
                        end
                    end
                end
            end
        end
    end
end)

-----------<HBE Function>


local Tab1 = TabBox:AddTab('Hitbox Expander')

local EnableHBX = Tab1:AddToggle('Enable', {
    Text = 'Enable',
    Default = false, 
    Tooltip = 'Enable hitbox expander', 
    
    Callback = function(HBEON)
        HeadExtends = HBEON 
    end
})

EnableHBX:AddColorPicker('ColorPicker', {
    Default = Color3.new(1, 1, 1), 
    Title = 'Hitbox Color', 
    Transparency = 0, 

    Callback = function(HBECOLOR)
        HBXColor = Color3.new(HBECOLOR.r, HBECOLOR.g, HBECOLOR.b)
    end
})


Tab1:AddDropdown('TargetDropdown', {
    Values = { 'Head', 'Torso' },
    Default = 1,
    Multi = false, 

    Text = 'Part',
    Tooltip = 'Part on which will be expanded', 

    Callback = function(HBETRAGET)
        selectedTarget = TargetOptions[HBETRAGET]
    end
})

Tab1:AddDropdown('MaterialDropdown', {
    Values = { "ForceField", "Neon", "Plastic", "Metal", "Wood", "Slate", "Concrete", "Foil", "DiamondPlate", "CorrodedMetal", "Grass", "Ice", "Marble", "Granite", "Brick", "Pebble", "Sand", "Fabric", "SmoothPlastic", "WoodPlanks", "Cobblestone", "Glass", "Asphalt", "LeafyGrass", "Salt", "Limestone", "Basalt" },
    Default = 1, 
    Multi = false, 

    Text = 'Material',
    Tooltip = 'Material of the hitbox', 

    Callback = function(HBEMATERIAL)
        selectedMaterial = TargetMaterial[HBEMATERIAL]
    end
})

Tab1:AddDropdown('ShapeDropdown', {
    Values = { 'Ball', 'Cube', 'Cylinder' },
    Default = 1, 
    Multi = false, 

    Text = 'Shape',
    Tooltip = 'Shape of the hitbox', 

    Callback = function(HBESHAPE)
        selectedShape = TargetShape[HBESHAPE]
    end
})


Tab1:AddSlider('TransparencySlider', {
    Text = 'Transparency',
    Default = 0.5,
    Min = 0,
    Max = 1,
    Rounding = 1,
    Compact = false,

    Callback = function(HBETRANS)
        HitboxTransparency = HBETRANS
    end
})


Tab1:AddSlider('HitboxSlider', {
    Text = 'Size',
    Default = 6,
    Min = 1,
    Max = 12,
    Rounding = 1,
    Compact = false,

    Callback = function(HBESIZE)
        Radius = HBESIZE
    end
})


local Tab2 = TabBox:AddTab('Head Expander')

local ENABLEBRUH = Tab2:AddToggle('Enable', {
    Text = 'Enable',
    Default = false, 
    Tooltip = 'Enable head expander', 

    Callback = function(HBEON2)
        HBXH = HBEON2
        local function AdjustHeadSize(i)
            if i:FindFirstChild("HumanoidRootPart") then
                if HBXH then
                    i.Head.Size = Vector3.new(SizeX, SizeY, SizeZ)
                    i.Head.Transparency = TransHead
                    i.Head.Color = ColorBRUH
                else
                    i.Head.Size = Vector3.new(1.672248125076294, 0.835624098777771, 0.835624098777771)
                    i.Head.Transparency = 0
                    i.Head.Color = Color3.fromRGB(80,77,56)
                end
            end
        end
        
        workspace.ChildAdded:Connect(function(child)
            AdjustHeadSize(child)
        end)
        
        for _, existingChild in pairs(workspace:GetChildren()) do
            AdjustHeadSize(existingChild)
        end
    end
})


ENABLEBRUH:AddColorPicker('ColorPicker', {
    Default = Color3.new(1, 1, 1), 
    Title = 'Color', 
    Transparency = 0, 

    Callback = function(BRUHGYAT)
        ColorBRUH = Color3.new(BRUHGYAT.r, BRUHGYAT.g, BRUHGYAT.b)
    end
})


Tab2:AddSlider('TransHeadLOL', {
    Text = 'Transparency',
    Default = 0,
    Min = 0,
    Max = 1,
    Rounding = 1,
    Compact = false,

    Callback = function(LOLGAY)
        TransHead = LOLGAY
    end
})

Tab2:AddSlider('HitboxSliderX', {
    Text = 'Size X',
    Default = 10,
    Min = 1,
    Max = 12,
    Rounding = 0,
    Compact = true,

    Callback = function(SX)
        SizeX = SX
    end
})

Tab2:AddSlider('HitboxSliderY', {
    Text = 'Size Y',
    Default = 10,
    Min = 1,
    Max = 12,
    Rounding = 0,
    Compact = true,

    Callback = function(SY)
        SizeY = SY
    end
})

Tab2:AddSlider('HitboxSliderZ', {
    Text = 'Size Z',
    Default = 10,
    Min = 1,
    Max = 12,
    Rounding = 0,
    Compact = true,

    Callback = function(SZ)
        SizeZ = SZ
    end
})




local TabBox4 = Tabs.Main:AddLeftTabbox() 


local PMTab1 = TabBox4:AddTab('Player Misc')

PMTab1:AddLabel('Loot All'):AddKeyPicker('KeyPicker', {

    Default = 'Non',
    SyncToggleState = false,

    Mode = 'Toggle', -- Modes: Always, Toggle, Hold

    Text = 'Loot All', 
    NoUI = false, 

    Callback = function(Value)
        for i = 1, 20 do
            local ohNumber1 = 12
            local ohNumber2 = i
            local ohBoolean3 = true
            game:GetService("Players").LocalPlayer.RemoteEvent:FireServer(ohNumber1, ohNumber2, ohBoolean3)
            end
    end,

        ChangedCallback = function(New)
            
        end
    })


    
PMTab1:AddLabel('Deposit All'):AddKeyPicker('KeyPicker', {

        Default = 'Non',
        SyncToggleState = false,
    
        Mode = 'Toggle', -- Modes: Always, Toggle, Hold
    
        Text = 'Deposit All', 
        NoUI = false, 
    
        Callback = function(Value)
            for i = 1, 20 do
                local ohNumber1 = 12
                local ohNumber2 = i
                local ohBoolean3 = false
                game:GetService("Players").LocalPlayer.RemoteEvent:FireServer(ohNumber1, ohNumber2, ohBoolean3)
                end
        end,

        
    ChangedCallback = function(New)
        
    end
})


PMTab1:AddLabel('Auto Bhop'):AddKeyPicker('KeyPicker', {

    Default = 'Non',
    SyncToggleState = false,

    Mode = 'Toggle', -- Modes: Always, Toggle, Hold

    Text = 'Bhop', 
    NoUI = false, 

    Callback = function(Value)
keypress(0x57)
keypress(0x10)
wait(0.05)
keypress(0x43)
keypress(0x20)
keyrelease(0x20)
wait(0.5)
keyrelease(0x43)
    end,

    
ChangedCallback = function(New)
    
end
})



local TabBox9 = Tabs.Main:AddRightTabbox() 
local PMPTab1 = TabBox9:AddTab('Player Custom')


local function setArmProperties(property, value)
    local armParts = {"LeftUpperArm", "LeftLowerArm", "LeftHand","RightUpperArm", "RightLowerArm", "RightHand"}
    for _, partName in ipairs(armParts) do
    game:GetService("Workspace").Ignore.FPSArms[partName][property] = value
    end
    end
    
    PMPTab1:AddToggle('ArmChams', { Text = 'Custom Arm', Default = false }):AddColorPicker('ArmChamsColor', { Default = Color3.fromRGB(80, 77, 56), Title = 'Color' }):OnChanged(function(Value)
    if Value == true then
    elseif Value == false then
    setArmProperties("Color", Color3.fromRGB(80, 77, 56))
    setArmProperties("Material", "SmoothPlastic")
    end
    end)
    Options.ArmChamsColor:OnChanged(function(Value)
    setArmProperties("Color", Value)
    end)
    
    PMPTab1:AddDropdown('ArmChamsMaterial', {Values = { "SmoothPlastic", "ForceField", "Neon", "Plastic", "Metal", "Wood", "Slate", "Concrete", "Foil", "DiamondPlate", "CorrodedMetal", "Grass", "Ice", "Marble", "Granite", "Brick", "Pebble", "Sand", "Fabric", "WoodPlanks", "Cobblestone", "Glass", "Asphalt", "LeafyGrass", "Salt", "Limestone", "Basalt" },Default = 1,Multi = false,Text = 'Material'}):OnChanged(function(Value)
    setArmProperties("Material", Value)
    end)
    
    
        local replicatedStorageLOL = game:GetService("ReplicatedStorage")
        local handModelsLOL = replicatedStorageLOL:WaitForChild("HandModels")
        local materialLOL = Enum.Material.ForceField
        local colorLOL = Color3.new(1, 1, 1)
    
    
    local CUSTOMBRUHWEAPON = PMPTab1:AddToggle('Enable', {
        Text = 'Custom Weapon',
        Default = false, 
        Tooltip = '', 
        
        Callback = function(LOL)
    
          for _, part in pairs(handModelsLOL:GetDescendants()) do
        if part:IsA("BasePart") then
            part.Material = materialLOL
            part.Color = colorLOL
        end
    end
    
        end
    })
    
    CUSTOMBRUHWEAPON:AddColorPicker('ColorPicker', {
        Default = Color3.new(1, 1, 1), 
        Title = 'Hitbox Color', 
        Transparency = 0, 
    
        Callback = function(WEAPONCOLRR)
            colorLOL = Color3.new(WEAPONCOLRR.r, WEAPONCOLRR.g, WEAPONCOLRR.b)
        end
    })
    
    
    PMPTab1:AddDropdown('MaterialDropdown', {
        Values = { "ForceField", "Neon", "Plastic", "Metal", "Wood", "Slate", "Concrete", "Foil", "DiamondPlate", "CorrodedMetal", "Grass", "Ice", "Marble", "Granite", "Brick", "Pebble", "Sand", "Fabric", "SmoothPlastic", "WoodPlanks", "Cobblestone", "Glass", "Asphalt", "LeafyGrass", "Salt", "Limestone", "Basalt" },
        Default = 1, 
        Multi = false, 
    
        Text = 'Material',
        Tooltip = '', 
    
        Callback = function(MATERIALWTFWEAPONS)
            materialLOL = TargetMaterial[MATERIALWTFWEAPONS]
        end
    })
    
    
    PMPTab1:AddDivider()
    
    
    PMPTab1:AddLabel('Health Color'):AddColorPicker('Health_Color_Value', { Default = Color3.fromRGB(78,153,74)})
    Options.Health_Color_Value:OnChanged(function(Health_Color_Value)
    game:GetService("Players").LocalPlayer.PlayerGui.GameUI.FPS.Vitals.HealthFrame.Health.BackgroundColor3 = Health_Color_Value
    end)
    
    
    PMPTab1:AddLabel('Energy Color'):AddColorPicker('Energy_Color_Value', { Default = Color3.fromRGB(197,187,40)})
    Options.Energy_Color_Value:OnChanged(function(Energy_Color_Value)
    game:GetService("Players").LocalPlayer.PlayerGui.GameUI.FPS.Vitals.EnergyFrame.Energy.BackgroundColor3 = Energy_Color_Value
    end)
    
    
    PMPTab1:AddLabel('Inventory Color'):AddColorPicker('Inventory_Color', { Default = Color3.fromRGB(80,80,80)})
    Options.Inventory_Color:OnChanged(function(Inventory_Color_Value)
    local hotbar = game:GetService("Players").LocalPlayer.PlayerGui.GameUI.FPS.BottomCenter
    for i = 26, 29 do
    hotbar.Armor["ItemSlot" .. i].BackgroundColor3 = Inventory_Color_Value
    end
    for i = 6, 25 do
    hotbar.Inventory["ItemSlot" .. i].BackgroundColor3 = Inventory_Color_Value
    end 
    for i = 1, 5 do
    hotbar.Hotbar["ItemSlot" .. i].BackgroundColor3 = Inventory_Color_Value
    end 
    end)


    PMPTab1:AddDivider()


    local SoundService = game:GetService("SoundService")

    SoundService.PlayerHitHeadshot.Volume = 0
    SoundService.PlayerHitHeadshot.Pitch = 1
    SoundService.PlayerHitHeadshot.EqualizerSoundEffect.HighGain = -1.5
    local sounds = {["Defualt Headshot"] = "rbxassetid://9119561046",["Defualt Body"] = "rbxassetid://9114487369",Neverlose = "rbxassetid://8726881116",Gamesense = "rbxassetid://4817809188",One = "rbxassetid://7380502345",Bell = "rbxassetid://6534947240",Rust = "rbxassetid://1255040462",TF2 = "rbxassetid://2868331684",Slime = "rbxassetid://6916371803",["Among Us"] = "rbxassetid://5700183626",Minecraft = "rbxassetid://4018616850",["CS:GO"] = "rbxassetid://6937353691",Saber = "rbxassetid://8415678813",Baimware = "rbxassetid://3124331820",Osu = "rbxassetid://7149255551",["TF2 Critical"] = "rbxassetid://296102734",Bat = "rbxassetid://3333907347",["Call of Duty"] = "rbxassetid://5952120301",Bubble = "rbxassetid://6534947588",Pick = "rbxassetid://1347140027",Pop = "rbxassetid://198598793",Bruh = "rbxassetid://4275842574",Bamboo = "rbxassetid://3769434519",Crowbar = "rbxassetid://546410481",Weeb = "rbxassetid://6442965016",Beep = "rbxassetid://8177256015",Bambi = "rbxassetid://8437203821",Stone = "rbxassetid://3581383408",["Old Fatality"] = "rbxassetid://6607142036",Click = "rbxassetid://8053704437",Ding = "rbxassetid://7149516994",Snow = "rbxassetid://6455527632",Laser = "rbxassetid://7837461331",Mario = "rbxassetid://2815207981",Steve = "rbxassetid://4965083997"}
    
    
    
    
    PMPTab1:AddToggle('Enabled_Toggle1', {Text = 'Headshot Hitsound', Default = false})
    
    PMPTab1:AddDropdown('HeadshotHit', {Values = { 'Defualt Headshot','Neverlose','Gamesense','One','Bell','Rust','TF2','Slime','Among Us','Minecraft','CS:GO','Saber','Baimware','Osu','TF2 Critical','Bat','Call of Duty','Bubble','Pick','Pop','Bruh','Bamboo','Crowbar','Weeb','Beep','Bambi','Stone','Old Fatality','Click','Ding','Snow','Laser','Mario','Steve','Snowdrake' },Default = 1, Multi = false, Text = 'Select'})
    Options.HeadshotHit:OnChanged(function()
    local soundId = sounds[Options.HeadshotHit.Value]
    game:GetService("SoundService").PlayerHitHeadshot.SoundId = soundId
    game:GetService("SoundService").PlayerHitHeadshot.Playing = true
    end)
    

    --
    PMPTab1:AddToggle('Enabled_Toggle2', {Text = 'Bodyshot Hitsound', Default = false})
    
    PMPTab1:AddDropdown('Hit', {Values = { 'Defualt Body','Neverlose','Gamesense','One','Bell','Rust','TF2','Slime','Among Us','Minecraft','CS:GO','Saber','Baimware','Osu','TF2 Critical','Bat','Call of Duty','Bubble','Pick','Pop','Bruh','Bamboo','Crowbar','Weeb','Beep','Bambi','Stone','Old Fatality','Click','Ding','Snow','Laser','Mario','Steve','Snowdrake' },Default = 1, Multi = false, Text = 'Select'})
    Options.Hit:OnChanged(function()
    local soundId = sounds[Options.Hit.Value]
    game:GetService("SoundService").PlayerHit2.SoundId = soundId
    game:GetService("SoundService").PlayerHit2.Playing = true
    end)
    



    local PMPTab2 = TabBox9:AddTab('Settings')

    PMPTab2:AddButton('Reset Colors', function()
        game:GetService("Players").LocalPlayer.PlayerGui.GameUI.FPS.Vitals.HealthFrame.Health.BackgroundColor3 = Color3.fromRGB(78,153,74)
        game:GetService("Players").LocalPlayer.PlayerGui.GameUI.FPS.Vitals.EnergyFrame.Energy.BackgroundColor3 = Color3.fromRGB(197,187,40)

        local hotbar = game:GetService("Players").LocalPlayer.PlayerGui.GameUI.FPS.BottomCenter
        for i = 26, 29 do
        hotbar.Armor["ItemSlot" .. i].BackgroundColor3 = Color3.fromRGB(80,80,80)
    end
        for i = 6, 25 do
        hotbar.Inventory["ItemSlot" .. i].BackgroundColor3 = Color3.fromRGB(80,80,80)
    end 
        for i = 1, 5 do
        hotbar.Hotbar["ItemSlot" .. i].BackgroundColor3 = Color3.fromRGB(80,80,80)
    end 
    end)

    PMPTab2:AddSlider('Volume_Slider', {Text = 'Headshot Volume', Default = 0, Min = 0, Max = 10, Rounding = 0, Compact = false,}):OnChanged(function(vol)
        SoundService.PlayerHitHeadshot.Volume = vol
        end)
        
    PMPTab2:AddSlider('Pitch_Slider', {Text = 'Headshot Pitch', Default = 1, Min = 0, Max = 2, Rounding = 2, Compact = false,}):OnChanged(function(pich)
        SoundService.PlayerHitHeadshot.Pitch = pich
        end)

PMPTab2:AddDivider()

    PMPTab2:AddSlider('Volume_Slider', {Text = 'Bodyshot Volume', Default = 0, Min = 0, Max = 10, Rounding = 0, Compact = false,}):OnChanged(function(vole)
        SoundService.PlayerHit2.Volume = vole
        end)
            
    PMPTab2:AddSlider('Pitch_Slider', {Text = 'Bodyshot Pitch', Default = 1, Min = 0, Max = 2, Rounding = 2, Compact = false,}):OnChanged(function(piche)
        SoundService.PlayerHit2.Pitch = piche
        end)


local VisualsTabBox = Tabs.Main:AddLeftTabbox('Crosshair')
local CrosshairXTab = VisualsTabBox:AddTab('Crosshair')

local Camera = game:GetService("Workspace").Camera
local Camera = game:GetService("Workspace").CurrentCamera
local Cam = game:GetService("Workspace").Camera

        --* Crosshair *--
        
        local CrossHairX = Drawing.new("Circle"), Drawing.new("Circle")
        --
        CrossHairX.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        CrossHairX.Thickness = 1
        CrossHairX.ZIndex = 3
        
        do
        CrosshairXTab:AddToggle('zCrosshairX_Toggle', {Text = 'Enable', Default = false}):AddColorPicker("eCrosshairX_Color", {Default = Color3.fromRGB(208, 123, 255)}):OnChanged(function()
        CrossHairX.Visible = Toggles.zCrosshairX_Toggle.Value
        end)
        
        Options.eCrosshairX_Color:OnChanged(function()
        CrossHairX.Color = Options.eCrosshairX_Color.Value
        end)
        
        CrosshairXTab:AddToggle('Crosshair_Filled1', {Text = 'Filled', Default = false}):OnChanged(function()
        CrossHairX.Filled = Toggles.Crosshair_Filled1.Value
        end)
        
        CrosshairXTab:AddSlider('Crosshair_Radius', {Text = 'Size', Suffix = "", Default = 2, Min = 0, Max = 100, Rounding = 0, Compact = true}):OnChanged(function(CrosshairXRadius)
        CrossHairX.Radius = CrosshairXRadius
        end)
        end


local Tabs = {
    Main = Window:AddTab('Visual'),

}


local TabBox2 = Tabs.Main:AddLeftTabbox() 


-----------<Visual LOCALS>

local ArmorColor = Color3.new(0, 1, 0)
local SleeperColor = Color3.new(0, 0, 1)
local distanceview = 800
local WepsColor = Color3.new(1, 1, 1)
local wallcheck = false
local TeamCheck = false
local WallColor = Color3.new(1, 0, 0)
local TeamCheColor = Color3.new(1, 1, 0)
local PlayerText = " Player "

-----------<Viusal LOCALS>


local VTab1 = TabBox2:AddTab('Player Visuals')

local PlayerLOC = VTab1:AddToggle('Player', {
    Text = 'Player',
    Default = false, 
    Tooltip = 'Shows "Player" text esp', 

    Callback = function(Value)
        local camera = workspace.CurrentCamera
        local runservice = game:GetService("RunService")
        
        function IsSleeping(Model)
            if Model and Model:FindFirstChild("AnimationController") and Model.AnimationController:FindFirstChild("Animator") then
                for i, v in pairs(Model.AnimationController.Animator:GetPlayingAnimationTracks()) do
                    if v.Animation.AnimationId == "rbxassetid://13280887764" then
                        return true
                    end
                end
            end
            return false
        end
        
        function Playeresp(drop)
            local dropesp = Drawing.new("Text")
            dropesp.Visible = false
            dropesp.Center = true
            dropesp.Outline = true
            dropesp.Font = 2
            dropesp.Size = 15
        
            local renderstepped
            renderstepped = runservice.RenderStepped:Connect(function()
                if drop and workspace:FindFirstChild(drop.Name) and drop:FindFirstChild("HumanoidRootPart") then
                    local drop_pos, drop_onscreen = camera:WorldToViewportPoint(drop.HumanoidRootPart.Position)
        
                    -- Calculate distance to humanoid
                    local distance = (drop.HumanoidRootPart.Position - camera.CFrame.Position).Magnitude
        
                    if drop_onscreen and distance <= distanceview then
                        if wallcheck then
                            -- Raycast to check for obstructions
                            local raycastParams = RaycastParams.new()
                            raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
                            raycastParams.FilterDescendantsInstances = { drop }
                            local raycastResult = workspace:Raycast(
                                camera.CFrame.Position,
                                drop.HumanoidRootPart.Position - camera.CFrame.Position,
                                raycastParams
                            )
        
                            dropesp.Position = Vector2.new(drop_pos.X, drop_pos.Y)
                            dropesp.Text = PlayerText
        
                            -- Check if the player is sleeping and set the text color
                            if IsSleeping(drop) then
                                dropesp.Color = SleeperColor -- White color for sleeping players
                            else
                                if not raycastResult then
                                    if TeamCheck then
                                        -- Check for Dot
                                        local head = drop:FindFirstChild("Head")
                                        local dot = head and head:FindFirstChild("Dot")
        
                                        if dot and dot:IsA("BillboardGui") and dot.Enabled then
                                            dropesp.Color = TeamCheColor -- Yellow color for players with enabled Dot
                                        else
                                            dropesp.Color = ArmorColor -- Green color for unobstructed and awake players
                                        end
                                    else
                                        dropesp.Color = ArmorColor -- Green color for unobstructed and awake players
                                    end
                                else
                                    dropesp.Color = WallColor -- Red color for obstructed players
                                end
                            end
                        else
                            dropesp.Position = Vector2.new(drop_pos.X, drop_pos.Y)
                            dropesp.Text = PlayerText
        
                            -- Check if the player is sleeping and set the text color
                            if IsSleeping(drop) then
                                dropesp.Color = SleeperColor -- White color for sleeping players
                            else
                                dropesp.Color = ArmorColor -- Green color for players
                            end
                        end
        
                        dropesp.Visible = true
                    else
                        dropesp.Visible = false
                    end
                else
                    dropesp.Visible = false
                    dropesp:Remove()
                    renderstepped:Disconnect()
                end
            end)
        end
        
        for i, drop in next, workspace:GetChildren() do
            if drop.Name == "Model" then
                if drop:FindFirstChild("HumanoidRootPart") then
                    Playeresp(drop)
                end
            end
        end
        
        workspace.ChildAdded:Connect(function(drop)
            if drop.Name == "Model" then
                if drop:FindFirstChild("HumanoidRootPart") then
                    Playeresp(drop)
                end
            end
        end)
        
    end
})


local HighlightLOC = VTab1:AddToggle('Highlight', {
    Text = 'Highlight',
    Default = false, 
    Tooltip = 'Show players in highlight', 

    Callback = function(Value)
        if true then
            while true do
               wait(1)
               for i, a in ipairs(workspace:GetChildren()) do
                  if a:FindFirstChild("HumanoidRootPart") then
                     if not a:FindFirstChild("Chamse") then
                        if a ~= game:GetService("Workspace").Ignore.FPSArms then
                           local b = Instance.new("Highlight", a)
                           b.Adornee = a
                           b.Name = "Chamse"
                           b.FillColor = Color3.fromRGB(25,25,25)
                           b.DepthMode = "AlwaysOnTop"
                           b.FillTransparency = 1
                           b.OutlineTransparency = 0  
                           b.OutlineColor = Color3.fromRGB(255,255,255)
                        end
                     end
                  end
               end
            end
            end
    end
})



local ArmorLOC = VTab1:AddToggle('Armor', {
    Text = 'Armor',
    Default = false, 
    Tooltip = 'Show players armors', 

    Callback = function(Value)
        local camera = workspace.CurrentCamera
        local runservice = game:GetService("RunService")
        
        function IsSleeping(Model)
            if Model and Model:FindFirstChild("AnimationController") and Model.AnimationController:FindFirstChild("Animator") then
                for i, v in pairs(Model.AnimationController.Animator:GetPlayingAnimationTracks()) do
                    if v.Animation.AnimationId == "rbxassetid://13280887764" then
                        return true
                    end
                end
            end
            return false
        end
        
        function espArmor(drop)
            local armorNameLabel = Drawing.new("Text")
            armorNameLabel.Visible = false
            armorNameLabel.Center = true
            armorNameLabel.Outline = true
            armorNameLabel.Font = 2
            armorNameLabel.Size = 15
        
            local renderstepped
            renderstepped = runservice.RenderStepped:Connect(function()
                if drop and drop:FindFirstChild("HumanoidRootPart") then
                    local drop_pos, drop_onscreen = camera:WorldToViewportPoint(drop.HumanoidRootPart.Position)
        
                    if drop_onscreen then
                        local distance = (camera.CFrame.Position - drop.HumanoidRootPart.Position).Magnitude
                        if distance <= distanceview then
                            local armorFolder = drop.Armor and drop.Armor:FindFirstChildOfClass("Folder")
                            if armorFolder then
                                local armorName = armorFolder.Name
                                if armorName == "WoodHelmet" or armorName == "WoodChestplate" or armorName == "WoodLeggings" then
                                    armorNameLabel.Position = Vector2.new(drop_pos.X, drop_pos.Y) - Vector2.new(0, -30)
                                    armorNameLabel.Text = "[WoodArmor]"
                                elseif armorName == "RiotHelmet" or armorName == "RiotChestplate" or armorName == "RiotLeggings" then
                                    armorNameLabel.Position = Vector2.new(drop_pos.X, drop_pos.Y) - Vector2.new(0, -30)
                                    armorNameLabel.Text = "[RiotArmor]"
                                elseif armorName == "SteelHelmet" or armorName == "SteelChestplate" or armorName == "SteelLeggings" then
                                    armorNameLabel.Position = Vector2.new(drop_pos.X, drop_pos.Y) - Vector2.new(0, -30)
                                    armorNameLabel.Text = "[SteelArmor]"
                                elseif armorName == "IronHelmet" or armorName == "IronChestplate" or armorName == "IronLeggings" then
                                    armorNameLabel.Position = Vector2.new(drop_pos.X, drop_pos.Y) - Vector2.new(0, -30)
                                    armorNameLabel.Text = "[IronArmor]"
                                else
                                    armorNameLabel.Position = Vector2.new(drop_pos.X, drop_pos.Y) - Vector2.new(0, -30)
                                    armorNameLabel.Text = "[None]"
                                end
        
                                -- Check if the player is sleeping and set the text color
                                if IsSleeping(drop) then
                                    armorNameLabel.Color = SleeperColor -- White color for sleeping players
                                else
                                    if wallcheck then
                                        -- Raycast to check for obstructions
                                        local raycastParams = RaycastParams.new()
                                        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
                                        raycastParams.FilterDescendantsInstances = { drop }
                                        local raycastResult = workspace:Raycast(
                                            camera.CFrame.Position,
                                            drop.HumanoidRootPart.Position - camera.CFrame.Position,
                                            raycastParams
                                        )
        
                                        if not raycastResult then
                                            if TeamCheck then
                                                -- Check for Dot
                                                local head = drop:FindFirstChild("Head")
                                                local dot = head and head:FindFirstChild("Dot")
        
                                                if dot and dot:IsA("BillboardGui") and dot.Enabled then
                                                    armorNameLabel.Color = TeamCheColor -- Yellow color for players with enabled Dot
                                                else
                                                    armorNameLabel.Color = ArmorColor -- Green color for unobstructed and awake players
                                                end
                                            else
                                                armorNameLabel.Color = ArmorColor -- Green color for unobstructed and awake players
                                            end
                                        else
                                            armorNameLabel.Color = WallColor -- Red color for obstructed players
                                        end
                                    else
                                        armorNameLabel.Color = ArmorColor -- Green color for players
                                    end
                                end
        
                                armorNameLabel.Visible = true
                            else
                                armorNameLabel.Position = Vector2.new(drop_pos.X, drop_pos.Y) - Vector2.new(0, -30)
                                armorNameLabel.Text = "[None]"
        
                                -- Check if the player is sleeping and set the text color
                                if IsSleeping(drop) then
                                    armorNameLabel.Color = SleeperColor -- White color for sleeping players
                                else
                                    if wallcheck then
                                        -- Raycast to check for obstructions
                                        local raycastParams = RaycastParams.new()
                                        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
                                        raycastParams.FilterDescendantsInstances = { drop }
                                        local raycastResult = workspace:Raycast(
                                            camera.CFrame.Position,
                                            drop.HumanoidRootPart.Position - camera.CFrame.Position,
                                            raycastParams
                                        )
        
                                        if not raycastResult then
                                            if TeamCheck then
                                                -- Check for Dot
                                                local head = drop:FindFirstChild("Head")
                                                local dot = head and head:FindFirstChild("Dot")
        
                                                if dot and dot:IsA("BillboardGui") and dot.Enabled then
                                                    armorNameLabel.Color = TeamCheColor -- Yellow color for players with enabled Dot
                                                else
                                                    armorNameLabel.Color = ArmorColor -- Green color for unobstructed and awake players
                                                end
                                            else
                                                armorNameLabel.Color = ArmorColor -- Green color for unobstructed and awake players
                                            end
                                        else
                                            armorNameLabel.Color = WallColor -- Red color for obstructed players
                                        end
                                    else
                                        armorNameLabel.Color = ArmorColor -- Green color for players
                                    end
                                end
        
                                armorNameLabel.Visible = true
                            end
                        else
                            armorNameLabel.Visible = false
                        end
                    else
                        armorNameLabel.Visible = false
                    end
                else
                    armorNameLabel.Visible = false
                    renderstepped:Disconnect()
                end
            end)
        end
        
        for _, drop in ipairs(workspace:GetDescendants()) do
            if drop:IsA("Model") and drop:FindFirstChild("HumanoidRootPart") then
                espArmor(drop)
            end
        end
        
        workspace.DescendantAdded:Connect(function(drop)
            if drop:IsA("Model") and drop:FindFirstChild("HumanoidRootPart") then
                espArmor(drop)
            end
        end)
        
    end
})


local WeaponLOC = VTab1:AddToggle('Weapon', {
    Text = 'Weapon',
    Default = false, 
    Tooltip = 'Show players weapons', 

    Callback = function(Value)
        local function applyItemESP(itemName)
            local function createESP(item, itemName)
               local a = Instance.new("BillboardGui", item)
               a.Name = "ItemESP"
               a.Size = UDim2.new(0, 100, 0, 20)  -- Adjust the size to fit the text comfortably
               a.AlwaysOnTop = true
               a.StudsOffset = Vector3.new(5, 5, 0)  -- Adjust the Y offset to move the ESP higher
         
               local b = Instance.new("Frame", a)
               b.Size = UDim2.new(1, 0, 1, 0)
               b.BackgroundTransparency = 1  -- Adjust transparency for a softer look
               b.BackgroundColor3 = Color3.new(0, 0.5, 0)  -- Dark green color
         
               local c = Instance.new('TextLabel', b)
               c.Size = UDim2.new(1, 0, 1, 0)
               c.BackgroundTransparency = 1
               c.TextSize = 20  -- Slightly smaller text size
               c.Font = Enum.Font.Arial  -- Apply Gotham font
               c.TextColor3 = WepsColor  -- White text color
               c.TextStrokeTransparency = 0.5
               c.TextStrokeColor3 = Color3.new(0, 0, 0)  -- Black text stroke
               c.Text = itemName
            end
         
            for _, v in pairs(game.workspace:GetDescendants()) do
               if v.Name == itemName then
                  createESP(v, itemName)
               end
            end
         
            game.workspace.DescendantAdded:Connect(function(item)
               if item.Name == itemName then
                  createESP(item, itemName)
               end
            end)
         end
         
         local itemsToApplyESP = {
            "Bow",
            "PipePistol",
            "Crossbow",
            "PipeSMG",
            "Blunderbuss",
            "USP9",
            "M4A1",
            "SteelHammer",
            "StoneHammer",
            "Hammer",
            "SCAR",
            "IronHammer",
            "RPG",
            "PumpShotgun",
            "MiningDrill",
            "LeverActionRifle",
            "HMAR",
            "GaussRifle",
            "FlameThrower",
            "Crowbar"
         }
         
         for _, itemName in ipairs(itemsToApplyESP) do
            applyItemESP(itemName)
         end
    end
})


local DistanceLOC = VTab1:AddToggle('Distance', {
    Text = 'Distance',
    Default = false, 
    Tooltip = 'Show players distance', 

    Callback = function(Value)
        local camera = workspace.CurrentCamera
        local runservice = game:GetService("RunService")


function IsSleeping(Model)
    if Model and Model:FindFirstChild("AnimationController") and Model.AnimationController:FindFirstChild("Animator") then
        for i, v in pairs(Model.AnimationController.Animator:GetPlayingAnimationTracks()) do
            if v.Animation.AnimationId == "rbxassetid://13280887764" then
                return true
            end
        end
    end
    return false
end

function espDistance(drop)
    local dropesp = Drawing.new("Text")
    dropesp.Visible = false
    dropesp.Center = true
    dropesp.Outline = true
    dropesp.Font = 2
    dropesp.Size = 15

    local renderstepped
    renderstepped = runservice.RenderStepped:Connect(function()
        if drop and workspace:FindFirstChild(drop.Name) and drop:FindFirstChild("HumanoidRootPart") then
            local drop_pos, drop_onscreen = camera:WorldToViewportPoint(drop.HumanoidRootPart.Position)

            if drop_onscreen then
                local distance = (camera.CFrame.Position - drop.HumanoidRootPart.Position).Magnitude
                if distance <= distanceview then
                    if wallcheck then
                        -- Raycast to check for obstructions
                        local raycastParams = RaycastParams.new()
                        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
                        raycastParams.FilterDescendantsInstances = { drop }
                        local raycastResult = workspace:Raycast(
                            camera.CFrame.Position,
                            drop.HumanoidRootPart.Position - camera.CFrame.Position,
                            raycastParams
                        )

                        dropesp.Position = Vector2.new(drop_pos.X, drop_pos.Y - -15) -- Adjusted position with a 15-pixel offset above
                        dropesp.Text = string.format("[ %.1f studs ]", distance)

                        -- Check if the player is sleeping and set the text color
                        if IsSleeping(drop) then
                            dropesp.Color = SleeperColor -- Green color for sleeping players
                        else
                            if not raycastResult then
                                if TeamCheck then
                                    -- Check for Dot
                                    local head = drop:FindFirstChild("Head")
                                    local dot = head and head:FindFirstChild("Dot")

                                    if dot and dot:IsA("BillboardGui") and dot.Enabled then
                                        dropesp.Color = TeamCheColor -- Yellow color for players with enabled Dot
                                    else
                                        dropesp.Color = ArmorColor -- Green color for unobstructed and awake players
                                    end
                                else
                                    dropesp.Color = ArmorColor -- Green color for unobstructed and awake players
                                end
                            else
                                dropesp.Color = WallColor -- Red color for obstructed players
                            end
                        end

                        dropesp.Visible = true
                    else
                        dropesp.Position = Vector2.new(drop_pos.X, drop_pos.Y - -15) -- Adjusted position with a 15-pixel offset above
                        dropesp.Text = string.format("[ %.1f studs ]", distance)

                        -- Check if the player is sleeping and set the text color
                        if IsSleeping(drop) then
                            dropesp.Color = SleeperColor -- Green color for sleeping players
                        else
                            dropesp.Color = ArmorColor -- Default color for awake players
                        end

                        dropesp.Visible = true
                    end
                else
                    dropesp.Visible = false
                end
            else
                dropesp.Visible = false
            end
        else
            dropesp.Visible = false
            dropesp:Remove()
            renderstepped:Disconnect()
        end
    end)
end

for i, drop in ipairs(workspace:GetChildren()) do
    if drop.Name == "Model" and drop:FindFirstChild("HumanoidRootPart") then
        espDistance(drop)
    end
end

workspace.ChildAdded:Connect(function(drop)
    if drop.Name == "Model" and drop:FindFirstChild("HumanoidRootPart") then
        espDistance(drop)
    end
end)

    end
})



local LineLOC = VTab1:AddToggle('Snapline', {
    Text = 'Snapline',
    Default = false, 
    Tooltip = 'Adds snaplines on players', 

    Callback = function(Value)
        local camera = workspace.CurrentCamera
        local runservice = game:GetService("RunService")

        
        function IsSleeping(Model)
            if Model and Model:FindFirstChild("AnimationController") and Model.AnimationController:FindFirstChild("Animator") then
                for i, v in pairs(Model.AnimationController.Animator:GetPlayingAnimationTracks()) do
                    if v.Animation.AnimationId == "rbxassetid://13280887764" then
                        return true
                    end
                end
            end
            return false
        end
        
        function esp(drop)
            local lineesp = Drawing.new("Line")
            lineesp.Visible = false
            lineesp.From = Vector2.new(0, 0)
            lineesp.To = Vector2.new(0, 0)
            lineesp.Thickness = 2
        
            local renderstepped
            renderstepped = runservice.RenderStepped:Connect(function()
                if drop and drop:IsDescendantOf(workspace) and drop:FindFirstChild("HumanoidRootPart") then
                    local drop_pos, drop_onscreen = camera:WorldToViewportPoint(drop.HumanoidRootPart.Position)
        
                    if drop_onscreen then
                        local distance = (camera.CFrame.Position - drop.HumanoidRootPart.Position).Magnitude
                        if distance <= distanceview then
                            if wallcheck then
                                -- Raycast to check for obstructions
                                local raycastParams = RaycastParams.new()
                                raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
                                raycastParams.FilterDescendantsInstances = { drop }
                                local raycastResult = workspace:Raycast(
                                    camera.CFrame.Position,
                                    drop.HumanoidRootPart.Position - camera.CFrame.Position,
                                    raycastParams
                                )
        
                                local topCenter = Vector2.new(camera.ViewportSize.X / 2, 0)
                                lineesp.From = topCenter
                                lineesp.To = Vector2.new(drop_pos.X, drop_pos.Y - 15)
                                lineesp.Visible = true
        
                                -- Check if the player is sleeping and set the line color
                                if IsSleeping(drop) then
                                    lineesp.Color = SleeperColor -- White color for sleeping players
                                else
                                    if not raycastResult then
                                        if TeamCheck then
                                            -- Check for Dot
                                            local head = drop:FindFirstChild("Head")
                                            local dot = head and head:FindFirstChild("Dot")
        
                                            if dot and dot:IsA("BillboardGui") and dot.Enabled then
                                                lineesp.Color = TeamCheColor -- Yellow color for players with enabled Dot
                                            else
                                                lineesp.Color = ArmorColor -- Green color for unobstructed and awake players
                                            end
                                        else
                                            lineesp.Color = ArmorColor -- Green color for unobstructed and awake players
                                        end
                                    else
                                        lineesp.Color = WallColor -- Red color for obstructed players
                                    end
                                end
                            else
                                local topCenter = Vector2.new(camera.ViewportSize.X / 2, 0)
                                lineesp.From = topCenter
                                lineesp.To = Vector2.new(drop_pos.X, drop_pos.Y - 15)
                                lineesp.Visible = true
        
                                -- Check if the player is sleeping and set the line color
                                if IsSleeping(drop) then
                                    lineesp.Color = SleeperColor -- White color for sleeping players
                                else
                                    lineesp.Color = ArmorColor -- Default color for awake players
                                end
                            end
                        else
                            lineesp.Visible = false
                        end
                    else
                        lineesp.Visible = false
                    end
                else
                    lineesp.Visible = false
                    lineesp:Remove()
                    renderstepped:Disconnect()
                end
            end)
        end
        
        for _, drop in ipairs(workspace:GetDescendants()) do
            if drop:IsA("Model") and drop:FindFirstChild("HumanoidRootPart") then
                esp(drop)
            end
        end
        
        workspace.DescendantAdded:Connect(function(drop)
            if drop:IsA("Model") and drop:FindFirstChild("HumanoidRootPart") then
                esp(drop)
            end
        end)
        
    end
})



local VTab2 = TabBox2:AddTab('Settings')

local WallCheckLOC = VTab2:AddToggle('Wallcheck', {
    Text = 'Wallcheck',
    Default = false, 
    Tooltip = 'Enable Wallcheck', 

    Callback = function(BRUHLOL)
        wallcheck = BRUHLOL
    end
})

WallCheckLOC:AddColorPicker('ColorPicker', {
    Default = Color3.new(1, 0, 0), 
    Title = 'Colorpicker', 
    Transparency = 0, 

    Callback = function(WALLCOLTOG)
        WallColor = Color3.new(WALLCOLTOG.r, WALLCOLTOG.g, WALLCOLTOG.b)
    end
})

local TeamCheckLOC = VTab2:AddToggle('BRUHcheck', {
    Text = 'Teamcheck',
    Default = false, 
    Tooltip = 'Enable Teamcheck', 

    Callback = function(LOLBRUH)
        TeamCheck = LOLBRUH
    end
})

TeamCheckLOC:AddColorPicker('ColorPicker', {
    Default = Color3.new(1, 1, 0), 
    Title = 'Colorpicker', 
    Transparency = 0, 

    Callback = function(TeamCOLTOG)
        TeamCheColor = Color3.new(TeamCOLTOG.r, TeamCOLTOG.g, TeamCOLTOG.b)
    end
})

VTab2:AddLabel('Awake/Default'):AddColorPicker('ColorPicker', {
    Default = Color3.new(0, 1, 0), 
    Title = 'ColorPicker', 
    Transparency = 0, 

    Callback = function(ColorTOG)
        ArmorColor = Color3.new(ColorTOG.r, ColorTOG.g, ColorTOG.b)
    end
})

VTab2:AddLabel('Sleepers'):AddColorPicker('ColorPicker', {
    Default = Color3.new(0, 0, 1), 
    Title = 'ColorPicker', 
    Transparency = 0,

    Callback = function(SleeperTOG)
        SleeperColor = Color3.new(SleeperTOG.r, SleeperTOG.g, SleeperTOG.b)
    end
})


VTab2:AddLabel('Weapons'):AddColorPicker('ColorPicker', {
    Default = Color3.new(1, 1, 1), 
    Title = 'ColorPicker', 
    Transparency = 0,

    Callback = function(WeaponTOG)
        WepsColor = Color3.new(WeaponTOG.r, WeaponTOG.g, WeaponTOG.b)
    end
})


VTab2:AddSlider('ViewDistanceESP', {
    Text = 'ViewDistance',
    Default = 800,
    Min = 100,
    Max = 2000,
    Rounding = 0,
    Compact = false,

    Callback = function(distanceOP)
        distanceview = distanceOP
    end
})

VTab2:AddInput('TextBoxPlayers', {
    Default = 'Player',
    Numeric = false, 
    Finished = true, 

    Text = 'Custom "Player" text',
    Tooltip = 'Customize "Player" text', 

    Placeholder = 'Text here', 
   

    Callback = function(TEXTVALUE)
        PlayerText = '' .. TEXTVALUE .. ''
    end
})



local TabBox3 = Tabs.Main:AddRightTabbox() 


local VWTab1 = TabBox3:AddTab('World Visuals')

local IronESP = VWTab1:AddToggle('IronOre', {
    Text = 'Iron Ore',
    Default = false, 
    Tooltip = 'Shows Iron ore esp', 

    Callback = function(Value)
        IronToggleAdornments()
    end
})

IronESP:AddColorPicker('ColorPicker', {
    Default = Color3.new(1, 1, 1), 
    Title = 'Colorpicker', 
    Transparency = 0, 

    Callback = function(IronTOG)
        IronColor = Color3.new(IronTOG.r, IronTOG.g, IronTOG.b)
    end
})


local StoneESP = VWTab1:AddToggle('StoneOre', {
    Text = 'Stone Ore',
    Default = false, 
    Tooltip = 'Shows Stone ore esp', 

    Callback = function(Value)
        StonetoggleAdornments()
    end
})

StoneESP:AddColorPicker('ColorPicker', {
    Default = Color3.new(1, 1, 1), 
    Title = 'Colorpicker', 
    Transparency = 0, 

    Callback = function(StoneTOG)
        StoneColor = Color3.new(StoneTOG.r, StoneTOG.g, StoneTOG.b)
    end
})


local NitrateESP = VWTab1:AddToggle('NitrateOre', {
    Text = 'Nitrate Ore',
    Default = false, 
    Tooltip = 'Shows Nitrate ore esp', 

    Callback = function(Value)
        NitratetoggleAdornments()
    end
})

NitrateESP:AddColorPicker('ColorPicker', {
    Default = Color3.new(1, 1, 1), 
    Title = 'Colorpicker', 
    Transparency = 0, 

    Callback = function(NitrateTOG)
        NitrateColor = Color3.new(NitrateTOG.r, NitrateTOG.g, NitrateTOG.b)
    end
})


VWTab1:AddDivider()

local PartBoxESP = VWTab1:AddToggle('PartBox', {
    Text = 'Part Box',
    Default = false, 
    Tooltip = 'Shows Partbox esp', 

    Callback = function(Value)
        PartBoxtoggleAdornments()
    end
})

PartBoxESP:AddColorPicker('ColorPicker', {
    Default = Color3.new(1, 1, 1), 
    Title = 'Colorpicker', 
    Transparency = 0, 

    Callback = function(PartBoxTOG)
        PartBoxColor = PartBoxTOG
    end
})


local MilitaryCrateESP = VWTab1:AddToggle('MilitaryCrate', {
    Text = 'Metal Crate',
    Default = false, 
    Tooltip = 'Shows Metalcrate esp', 

    Callback = function(Value)
        MetalCratetoggleAdornments()
    end
})

MilitaryCrateESP:AddColorPicker('ColorPicker', {
    Default = Color3.new(1, 1, 1), 
    Title = 'Colorpicker', 
    Transparency = 0, 

    Callback = function(MetalCrateTOG)
        MetalCrateColor = MetalCrateTOG
    end
})


local VendingMachineESP = VWTab1:AddToggle('VendingMachine', {
    Text = 'Vending Machine',
    Default = false, 
    Tooltip = 'Shows VendingMachine esp', 

    Callback = function(Value)
        VendingMachinetoggleAdornments()
    end
})

VendingMachineESP:AddColorPicker('ColorPicker', {
    Default = Color3.new(1, 1, 1), 
    Title = 'Colorpicker', 
    Transparency = 0, 

    Callback = function(VendingMachineTOG)
        VendingMachineColor = VendingMachineTOG
    end
})

VWTab1:AddDivider()

local ClaimTotemESP = VWTab1:AddToggle('ClaimTotem', {
    Text = 'Claim Totem',
    Default = false, 
    Tooltip = 'Shows ClaimTotem esp', 

    Callback = function(Value)
        ClaimTotemtoggleAdornments()
    end
})

ClaimTotemESP:AddColorPicker('ColorPicker', {
    Default = Color3.new(1, 1, 1), 
    Title = 'Colorpicker', 
    Transparency = 0, 

    Callback = function(ClaimTotemTOG)
        ClaimTotemColor = ClaimTotemTOG
    end
})



local RespawnESP = VWTab1:AddToggle('Respawn', {
    Text = 'Respawn Totem',
    Default = false, 
    Tooltip = 'Shows Respawn totems esp', 

    Callback = function(Value)
        RespawnTotemtoggleAdornments()
    end
})

RespawnESP:AddColorPicker('ColorPicker', {
    Default = Color3.new(1, 1, 1), 
    Title = 'Colorpicker', 
    Transparency = 0, 

    Callback = function(RespawnTotemTOG)
        RespawnTotemColor = RespawnTotemTOG
    end
})


local CabinetESP = VWTab1:AddToggle('Cabinet', {
    Text = 'Cabinet',
    Default = false, 
    Tooltip = 'Shows Cabinet esp', 

    Callback = function(Value)
        CabinettoggleAdornments()
    end
})

CabinetESP:AddColorPicker('ColorPicker', {
    Default = Color3.new(1, 1, 1), 
    Title = 'Colorpicker', 
    Transparency = 0, 

    Callback = function(CabinetTOG)
        CabinetColor = CabinetTOG
    end
})



local SmallLargeBoxESP = VWTab1:AddToggle('SmallBox', {
    Text = 'Small Box',
    Default = false, 
    Tooltip = 'Shows Small Box esp', 

    Callback = function(Value)
        SmallBoxtoggleAdornments()
    end
})

SmallLargeBoxESP:AddColorPicker('ColorPicker', {
    Default = Color3.new(1, 1, 1), 
    Title = 'Colorpicker', 
    Transparency = 0, 

    Callback = function(SmallBoxTOG)
        SmallBoxColor = SmallBoxTOG
    end
})


local SmallLargeBoxESP = VWTab1:AddToggle('LargeBox', {
    Text = 'Medium Box',
    Default = false, 
    Tooltip = 'Shows Medium Box esp', 

    Callback = function(Value)
        MediumBoxtoggleAdornments()
    end
})

SmallLargeBoxESP:AddColorPicker('ColorPicker', {
    Default = Color3.new(1, 1, 1), 
    Title = 'Colorpicker', 
    Transparency = 0, 

    Callback = function(LargeBoxTOG)
        MediumBoxColor = LargeBoxTOG
    end
})




local VWTab2 = TabBox3:AddTab('Settings')

VWTab2:AddSlider('ViewDistanceESP', {
    Text = 'ViewDistance',
    Default = 500,
    Min = 100,
    Max = 1000,
    Rounding = 0,
    Compact = false,

    Callback = function(BLUR)
        maxDistance = BLUR
    end
})










local Tabs = {
    Main = Window:AddTab('Misc'),

}

local TabBox5 = Tabs.Main:AddLeftTabbox() 

-----------<WMisc LOCALS>

local LightingEnabled = true
local RemoveCloudsToggle = false
local GrassRemove = false
local LeavesON = false 

-----------<WMisc LOCALS>



local MTab1 = TabBox5:AddTab('World Misc')

MTab1:AddToggle('NoGrass', {
    Text = 'No Grass',
    Default = false, 
    Tooltip = 'Remove all grass', 

    Callback = function(RGRASS)
        GrassRemove = RGRASS

        if LightingEnabled and GrassRemove == true then
            sethiddenproperty(game.Workspace.Terrain, "Decoration", false)
            elseif LightingEnabled and GrassRemove == false then
            sethiddenproperty(game.Workspace.Terrain, "Decoration", true)
            end
    end
})

MTab1:AddToggle('NoTrees', {
    Text = 'No Leaves',
    Default = false, 
    Tooltip = 'Remove all tree leaves', 

    Callback = function(LEVESONE)
        LeavesON = LEVESONE 

local originalSizes = {} -- Store the original sizes of the items

local function storeOriginalSize(item)
    if not originalSizes[item] then
        originalSizes[item] = item.Size -- Store the original size if it hasn't been stored yet
    end
end

local function applyItemTransformation(itemName)
    for _, v in pairs(game.workspace:GetDescendants()) do
        if v.Name == itemName then
            if LeavesON then
                storeOriginalSize(v)
                v.Size = Vector3.new(0, 0, 0) -- Set size to (0, 0, 0) when LeavesON is true
            else
                if originalSizes[v] then
                    v.Size = originalSizes[v] -- Restore the original size when LeavesON is false
                end
            end
        end
    end

    game.workspace.DescendantAdded:Connect(function(item)
        if item.Name == itemName then
            if LeavesON then
                item.Size = Vector3.new(0, 0, 0) -- Set size to (0, 0, 0) for newly added items when LeavesON is true
                storeOriginalSize(item)
            elseif originalSizes[item] then
                item.Size = originalSizes[item] -- Restore the original size for newly added items when LeavesON is false
            end
        end
    end)
end

local itemsToApplyTransformation = {
    "Elm1_Leaves",
    "Brich1_Leaves",
    "Fir3_Leaves",
    "Palm1_Leaves"
}

for _, itemName in ipairs(itemsToApplyTransformation) do
    applyItemTransformation(itemName)
end

    end
})

MTab1:AddToggle('NoClouds', {
    Text = 'No Clouds',
    Default = false, 
    Tooltip = 'Remove all clouds', 

    Callback = function(RCLOUDS)
        RemoveCloudsToggle = RCLOUDS

        if LightingEnabled and RemoveCloudsToggle == true then
            sethiddenproperty(game:GetService("Workspace").Terrain.Clouds, "Enabled", false)
            elseif LightingEnabled and RemoveCloudsToggle == false then
            sethiddenproperty(game:GetService("Workspace").Terrain.Clouds, "Enabled", true)
            end
    end
})


local TabBox10 = Tabs.Main:AddRightTabbox() 


local MC30Tab1 = TabBox10:AddTab('Local Misc')

MC30Tab1:AddButton('Freecam', function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/RobloxSkriptr/RBLXSkriptr/main/Free%20Camera.lua",true))()
end)



local Tabs = {
    Main = Window:AddTab('BanLand'),
    ['UI Settings'] = Window:AddTab('UI Settings'),

}

local oldTick = tick()
local Camera = game:GetService("Workspace").CurrentCamera
local CharcaterMiddle = game:GetService("Workspace").Ignore.LocalCharacter.Middle
local Mouse = game.Players.LocalPlayer:GetMouse()

local Functions = {}
local Esp = {
  Settings = {
      Boxes = false,
      BoxesOutline = true,
      BoxesColor = Color3.fromRGB(255,145,164),
      BoxesOutlineColor = Color3.fromRGB(0, 0, 0),
      Sleeping = false,
      SleepingColor = Color3.fromRGB(255,145,164),
      Distances = false,
      DistanceColor = Color3.fromRGB(255,145,164),
      Armour = false,
      ArmourColor = Color3.fromRGB(255,145,164),
      Tool = false,
      ToolColor = Color3.fromRGB(255,128,114),
      Tracer = false,
      TracerColor = Color3.fromRGB(255,145,164),
      TracerThickness = 1,
      TracerTransparrency = 1,
      TracerFrom = "Bottom",
      ViewAngle = false,
      ViewAngleColor = Color3.fromRGB(250,128,114),
      ViewAngleThickness = 1,
      ViewAngleTransparrency = 1,
      OreDistances = false,
      OreDistanceColor = Color3.fromRGB(250,128,114),
      OreNames = false,
      OreNamesColor = Color3.fromRGB(250,128,114),
      OresRenderDistance = 1500,
      TextFont = 2,
      TextOutline = true,
      TextSize = 15,
      RenderDistance = 1500,
      TeamCheck = false,
      TargetSleepers = false,
      MinTextSize = 8,
  },
  Drawings = {},
  Connections = {},
  Players = {},
  Ores = {},
  StorageThings = {},
}
local Fonts = { ["UI"] = 0, ["System"] = 1, ["Plex"] = 2, ["Monospace"] = 3 }
local cache = {}
local Fov = {Settings={
  FovEnabled=false,
  FovColor=Color3.fromRGB(255,255,255),
  FovSize=0,
  FovFilled=false,
  FovTransparency=0,
  OutlineFovColor=Color3.fromRGB(0,0,0),
  RealFovSize=0,
  FovPosition="Screen",
  Snapline=false,
  SnaplineColor=Color3.fromRGB(255,255,255)
}}
local Combat = {Settings={
  SilentEnabled=true,
  SilentHitChance=100,
  SilentAimPart="Head",
  TeamCheck=true,
  SleeperCheck=true,
}}
local cache = {}

--// Silent Aim -()
function Functions:GetClosest()
  local closest,PlayerDistance,playerTable = nil,Combat.Settings.RenderDistance,nil
  for i,v in pairs(getupvalues(getrenv()._G.modules.Player.GetPlayerModel)[1]) do
    if v.model:FindFirstChild("HumanoidRootPart") and Combat.Settings.SleeperCheck == true and v.sleeping == nil then
      local Mouse = game.Players.LocalPlayer:GetMouse()
      local pos,OnScreen = Camera.WorldToViewportPoint(Camera, v.model:GetPivot().Position)
      local MouseMagnitude = (Vector2.new(pos.X, pos.Y) - Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)).Magnitude
      local PlayerDistance = (CharcaterMiddle:GetPivot().Position-v.model:GetPivot().Position).Magnitude
      if MouseMagnitude < Fov.Settings.FovSize and PlayerDistance <= Combat.Settings.RenderDistance and OnScreen == true then
        closest = v.model;PlayerDistance = PlayerDistance;playerTable=v
      end
    elseif v.model:FindFirstChild("HumanoidRootPart") and Combat.Settings.SleeperCheck == false then
      local Mouse = game.Players.LocalPlayer:GetMouse()
      local pos,OnScreen = Camera.WorldToViewportPoint(Camera, v.model:GetPivot().Position)
      local MouseMagnitude = (Vector2.new(pos.X, pos.Y) - Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)).Magnitude
      local PlayerDistance = (CharcaterMiddle:GetPivot().Position-v.model:GetPivot().Position).Magnitude
      if MouseMagnitude < Fov.Settings.FovSize and PlayerDistance <= Combat.Settings.RenderDistance and OnScreen == true then
        closest = v.model;PlayerDistance = PlayerDistance;playerTable=v
      end
    end
  end
  return closest,playerTable
end
function Functions:GetProjectileInfo()
  if getrenv()._G.modules.FPS.GetEquippedItem() == nil then return 0,0 end
  local mod = require(game:GetService("ReplicatedStorage").ItemConfigs[getrenv()._G.modules.FPS.GetEquippedItem().id])
  for i,v in pairs(mod) do
    if i == "ProjectileSpeed" or i == "ProjectileDrop" then
      return mod.ProjectileSpeed,mod.ProjectileDrop
    end
  end
  return 0,0
end
function Functions:Predict()
  local Prediction = Vector3.new(0,0,0)
  local Drop = Vector3.new(0,0,0)
  if Functions:GetClosest() ~= nil then
    local ps,pd = Functions:GetProjectileInfo()
    local Player,PlayerTable = Functions:GetClosest()
    local Velocity = PlayerTable.velocityVector
    local Distance = (CharcaterMiddle.Position - Player[Combat.Settings.SilentAimPart].Position).Magnitude
    if ps == 0 then
      ps = 500
    end
    if pd == 0 then
      pd = 1
    end
    local TimeOfFlight = Distance / ps
    newps = ps - 13 * ps ^ 2 * TimeOfFlight ^ 2
    TimeOfFlight += (Distance / newps)
    local dropTime = pd * TimeOfFlight ^ 2
    if Velocity and TimeOfFlight then
      Drop = Vector3.new(0,(dropTime * 20)*.4,0)
      Prediction = (Velocity * (TimeOfFlight*8)) * .70
    end
    Prediction = Prediction + Drop
  end
  return Prediction,Drop
end

--// Player ESP -()
function Functions:Draw(Type,Propities)
  if not Type and not Propities then return end
  local drawing = Drawing.new(Type)
  for i,v in pairs(Propities) do
    drawing[i] = v
  end
  table.insert(Esp.Drawings,drawing)
  return drawing
end
function Esp:CreateEsp(PlayerTable)
  if not PlayerTable then return end
  local drawings = {}
  drawings.BoxOutline = Functions:Draw("Square",{Thickness=2,Filled=false,Transparency=1,ZIndex = -1,Visible=false});
  drawings.Box = Functions:Draw("Square",{Thickness=1,Filled=false,Transparency=1,Color=Esp.Settings.BoxesColor,Color=Esp.Settings.OtherBoxesColor,Color=Esp.Settings.OtherBoxesColorTeam,ZIndex = 2,Visible=false});
  drawings.BoxFilled = Functions:Draw("Square",{Thickness=1,Filled=true,Transparency=Esp.Settings.BoxesFilledTransparency,Color=Esp.Settings.BoxesFilledColor,ZIndex = 2,Visible=false});
  drawings.Sleeping = Functions:Draw("Text",{Text = "Nil",Font=Esp.Settings.TextFont,Size=Esp.Settings.TextSize,Center=true,Outline=Esp.Settings.TextOutline,Color = Esp.Settings.SleepingColor,Color = Esp.Settings.OtherSleepingColor,Color = Esp.Settings.OtherSleepingColorTeam,ZIndex = 2,Visible=false})
  drawings.Distance = Functions:Draw("Text",{Text = "[nil]",Font=Esp.Settings.TextFont,Size=Esp.Settings.TextSize,Center=true,Outline=Esp.Settings.TextOutline,Color = Esp.Settings.DistanceColor,Color = Esp.Settings.OtherDistanceColor,Color = Esp.Settings.OtherDistanceColorTeam,ZIndex = 2,Visible=false})
  drawings.Armour = Functions:Draw("Text",{Text = "",Font=Esp.Settings.TextFont,Size=Esp.Settings.TextSize,Center=true,Outline=Esp.Settings.TextOutline,Color = Esp.Settings.ArmourColor,Color = Esp.Settings.OtherArmourColor,Color = Esp.Settings.OtherArmourColorTeam,ZIndex = 2,Visible=false})
  drawings.Tool = Functions:Draw("Text",{Text = "Empty",Font=Esp.Settings.TextFont,Size=Esp.Settings.TextSize,Center=true,Outline=Esp.Settings.TextOutline,Color = Esp.Settings.ToolColor,Color = Esp.Settings.OtherToolColor,Color = Esp.Settings.OtherToolColorTeam,ZIndex = 2,Visible=false})
  drawings.ViewAngle = Functions:Draw("Line",{Thickness=Esp.Settings.ViewAngleThickness,Transparency=Esp.Settings.ViewAngleTransparrency,Color=Esp.Settings.ViewAngleColor,Color=Esp.Settings.OtherViewAngleColor,Color=Esp.Settings.OtherViewAngleColorTeam,ZIndex=2,Visible=false})
  drawings.HeadCircles = Functions:Draw("Circle",{Thickness=Esp.Settings.HeadCirclesThickness,Transparency=Esp.Settings.HeadCirclesTransparrency,Color=Esp.Settings.HeadCirclesColor,Color=Esp.Settings.OtherHeadCirclesColor,Color=Esp.Settings.OtherHeadCirclesColorTeam,ZIndex=2,Visible=false})
  drawings.Tracer = Functions:Draw("Line",{Thickness=Esp.Settings.TracerThickness,Transparency=1,Color=Esp.Settings.TracerColor,Color=Esp.Settings.OtherTracerColor,Color=Esp.Settings.OtherTracerColorTeam,ZIndex=2,Visible=false})
  drawings.Line1 = Functions:Draw("Line",{Thickness=Esp.Settings.CornerEspThickness,Transparency=1,Color=Esp.Settings.BoxesColor,ZIndex=2,Visible=false});drawings.Line2 = Functions:Draw("Line",{Thickness=Esp.Settings.CornerEspThickness,Transparency=1,Color=Esp.Settings.BoxesColor,ZIndex=2,Visible=false});drawings.Line3 = Functions:Draw("Line",{Thickness=Esp.Settings.CornerEspThickness,Transparency=1,Color=Esp.Settings.BoxesColor,ZIndex=2,Visible=false});drawings.Line4 = Functions:Draw("Line",{Thickness=Esp.Settings.CornerEspThickness,Transparency=1,Color=Esp.Settings.BoxesColor,ZIndex=2,Visible=false});drawings.Line5 = Functions:Draw("Line",{Thickness=Esp.Settings.CornerEspThickness,Transparency=1,Color=Esp.Settings.BoxesColor,ZIndex=2,Visible=false});drawings.Line6 = Functions:Draw("Line",{Thickness=Esp.Settings.CornerEspThickness,Transparency=1,Color=Esp.Settings.BoxesColor,ZIndex=2,Visible=false});drawings.Line7 = Functions:Draw("Line",{Thickness=Esp.Settings.CornerEspThickness,Transparency=1,Color=Esp.Settings.BoxesColor,ZIndex=2,Visible=false});drawings.Line8 = Functions:Draw("Line",{Thickness=Esp.Settings.CornerEspThickness,Transparency=1,Color=Esp.Settings.BoxesColor,ZIndex=2,Visible=false})
  drawings.PlayerTable = PlayerTable
  Esp.Players[PlayerTable.model] = drawings
end
function Esp:RemoveEsp(PlayerTable)
  if not PlayerTable and PlayerTable.model ~= nil then return end
  esp = Esp.Players[PlayerTable.model];
  if not esp then return end
  for i, v in pairs(esp) do
    if not type(v) == "table" then
      v:Remove();
    end
  end
  Esp.Players[PlayerTable.model] = nil;
end
function Esp:UpdateEsp()
  for i,v in pairs(Esp.Players) do
    local Character = i
    local Position,OnScreen = Camera:WorldToViewportPoint(Character:GetPivot().Position);
    local scale = 1 / (Position.Z * math.tan(math.rad(Camera.FieldOfView * 0.5)) * 2) * 100;
    local w,h = math.floor(40 * scale), math.floor(55 * scale);
    local x,y = math.floor(Position.X), math.floor(Position.Y);
    local Distance = (CharcaterMiddle:GetPivot().Position-Character:GetPivot().Position).Magnitude
    local BoxPosX,BoxPosY = math.floor(x - w * 0.5),math.floor(y - h * 0.5)
    local offsetCFrame = CFrame.new(0, 0, -4)
    local IsVisible = false
    if Character and Character:FindFirstChild("HumanoidRootPart") and Character:FindFirstChild("Head") and Character.Parent == game.Workspace then
      local TeamTag = Character.Head.Teamtag.Enabled
      local ccc,ttt = Functions:GetClosest()
      if OnScreen == true and Esp.Settings.Boxes == true and Distance <= Esp.Settings.RenderDistance then
        if Esp.Settings.TeamCheck == true and TeamTag == false then
          v.BoxOutline.Visible = Esp.Settings.BoxesOutline;v.Box.Visible = true;v.BoxFilled.Visible=Esp.Settings.BoxesFilled
        elseif Esp.Settings.TeamCheck == true and TeamTag == true then
          v.BoxOutline.Visible = false;v.Box.Visible = false;v.BoxFilled.Visible=false
        else
          v.BoxOutline.Visible = Esp.Settings.BoxesOutline;v.Box.Visible = true;v.BoxFilled.Visible=Esp.Settings.BoxesFilled
        end
        if Esp.Settings.TargetSleepers == true and v.PlayerTable.sleeping == true then
          v.BoxOutline.Visible = false;v.Box.Visible = false;v.BoxFilled.Visible = false
        end
        v.BoxOutline.Position = Vector2.new(BoxPosX,BoxPosY);v.BoxOutline.Size = Vector2.new(w,h)
        v.Box.Position = Vector2.new(BoxPosX,BoxPosY);v.Box.Size = Vector2.new(w,h)
        v.Box.Color = Esp.Settings.BoxesColor;v.BoxOutline.Color = Color3.fromRGB(0, 0, 0)
        v.BoxOutline.Transparency = 1
        v.BoxFilled.Position=Vector2.new(BoxPosX,BoxPosY);v.BoxFilled.Size=Vector2.new(w,h)
        v.BoxFilled.Transparency = Esp.Settings.BoxesFilledTransparency
        v.BoxFilled.Color = Esp.Settings.BoxesFilledColor
        if IsVisible == true then
          v.Box.Color = Color3.fromRGB(255,0,0);v.BoxOutline.Color=Esp.Settings.BoxesOutlineColor;v.BoxFilled.Color=Color3.fromRGB(0,0,0)
        else
          v.Box.Color = Esp.Settings.BoxesColor;v.BoxOutline.Color = Esp.Settings.BoxesOutlineColor;v.BoxFilled.Color=Esp.Settings.BoxesFilledColor
        end
        if Esp.Settings.HighlightTarget and Character == ccc then
          v.Box.Color = Esp.Settings.HighlightTargetColor
        else
          v.Box.Color = Esp.Settings.BoxesColor;
        end
        if v.PlayerTable.sleeping == true then v.Box.Color = Esp.Settings.OtherBoxesColor end
        if TeamTag == true then v.Sleeping.Text = "Friendly" end
        if TeamTag == true then v.Box.Color = Esp.Settings.OtherBoxesColorTeam end
      else
        v.BoxOutline.Visible = false;v.Box.Visible = false;v.BoxFilled.Visible = false;
      end
      if OnScreen == true and Esp.Settings.CornerBoxes == true and Distance <= Esp.Settings.RenderDistance then
        if Esp.Settings.TeamCheck == true and TeamTag == false then
          v.BoxFilled.Visible=Esp.Settings.BoxesFilled
          v.Line1.Visible=Esp.Settings.CornerBoxes;v.Line2.Visible=Esp.Settings.CornerBoxes;v.Line3.Visible=Esp.Settings.CornerBoxes;v.Line4.Visible=Esp.Settings.CornerBoxes;v.Line5.Visible=Esp.Settings.CornerBoxes;v.Line6.Visible=Esp.Settings.CornerBoxes;v.Line7.Visible=Esp.Settings.CornerBoxes;v.Line8.Visible=Esp.Settings.CornerBoxes
        elseif Esp.Settings.TeamCheck == true and TeamTag == true then
          v.Line1.Visible=false;v.Line2.Visible=false;v.Line3.Visible=false;v.Line4.Visible=false;v.Line5.Visible=false;v.Line6.Visible=false;v.Line7.Visible=false;v.Line8.Visible=false
          v.BoxFilled.Visible=false
        else
          v.BoxFilled.Visible=Esp.Settings.BoxesFilled
          v.Line1.Visible=Esp.Settings.CornerBoxes;v.Line2.Visible=Esp.Settings.CornerBoxes;v.Line3.Visible=Esp.Settings.CornerBoxes;v.Line4.Visible=Esp.Settings.CornerBoxes;v.Line5.Visible=Esp.Settings.CornerBoxes;v.Line6.Visible=Esp.Settings.CornerBoxes;v.Line7.Visible=Esp.Settings.CornerBoxes;v.Line8.Visible=Esp.Settings.CornerBoxes
        end
        if Esp.Settings.TargetSleepers == true and v.PlayerTable.sleeping == true then
          v.Line1.Visible=false;v.Line2.Visible=false;v.Line3.Visible=false;v.Line4.Visible=false;v.Line5.Visible=false;v.Line6.Visible=false;v.Line7.Visible=false;v.Line8.Visible=false
          v.BoxFilled.Visible = false
        end
        v.Line1.From=Vector2.new(BoxPosX,BoxPosY);v.Line1.To=Vector2.new((BoxPosX+w/4),BoxPosY) --Top Left Top
        v.Line2.From=Vector2.new(BoxPosX+w,BoxPosY);v.Line2.To=Vector2.new((BoxPosX+w)-w/4,BoxPosY) -- Top Right Top
        v.Line3.From=Vector2.new(BoxPosX,BoxPosY+h);v.Line3.To=Vector2.new((BoxPosX+w/4),BoxPosY+h) -- Bottom Left Bottom
        v.Line4.From=Vector2.new(BoxPosX+w,BoxPosY+h);v.Line4.To=Vector2.new((BoxPosX+w)-w/4,BoxPosY+h) --Bottom Right Bottom
        v.Line5.From=Vector2.new(BoxPosX,BoxPosY);v.Line5.To=Vector2.new(BoxPosX,BoxPosY+h/8) --Top Left Down
        v.Line6.From=Vector2.new(BoxPosX,BoxPosY+h);v.Line6.To=Vector2.new(BoxPosX,(BoxPosY+h)-h/8) --Bottom Left Up
        v.Line7.From=Vector2.new(BoxPosX+w,BoxPosY+h);v.Line7.To=Vector2.new(BoxPosX+w,(BoxPosY+h)-h/8) --Bottom Right Up
        v.Line8.From=Vector2.new(BoxPosX+w,BoxPosY);v.Line8.To=Vector2.new(BoxPosX+w,BoxPosY+h/8) --Top Right Down
        v.BoxFilled.Position=Vector2.new(BoxPosX,BoxPosY);v.BoxFilled.Size=Vector2.new(w,h)
        v.BoxFilled.Transparency = Esp.Settings.BoxesFilledTransparency
        if IsVisible == true then
          v.Line1.Color=Color3.fromRGB(255,0,0);v.Line2.Color=Color3.fromRGB(255,0,0);v.Line3.Color=Color3.fromRGB(255,0,0);v.Line4.Color=Color3.fromRGB(255,0,0);v.Line5.Color=Color3.fromRGB(255,0,0);v.Line6.Color=Color3.fromRGB(255,0,0);v.Line7.Color=Color3.fromRGB(255,0,0);v.Line8.Color=Color3.fromRGB(255,0,0)
          v.BoxFilled.Color=Color3.fromRGB(255,0,0)
        else
          v.Line1.Color=Esp.Settings.BoxesColor;v.Line2.Color=Esp.Settings.BoxesColor;v.Line3.Color=Esp.Settings.BoxesColor;v.Line4.Color=Esp.Settings.BoxesColor;v.Line5.Color=Esp.Settings.BoxesColor;v.Line6.Color=Esp.Settings.BoxesColor;v.Line7.Color=Esp.Settings.BoxesColor;v.Line8.Color=Esp.Settings.BoxesColor
          v.BoxFilled.Color=Esp.Settings.BoxesFilledColor
        end
        if Esp.Settings.HighlightTarget and Character == ccc then
          v.Line1.Color = Esp.Settings.HighlightTargetColor
          v.Line2.Color = Esp.Settings.HighlightTargetColor
          v.Line3.Color = Esp.Settings.HighlightTargetColor
          v.Line4.Color = Esp.Settings.HighlightTargetColor
          v.Line5.Color = Esp.Settings.HighlightTargetColor
          v.Line6.Color = Esp.Settings.HighlightTargetColor
          v.Line7.Color = Esp.Settings.HighlightTargetColor
          v.Line8.Color = Esp.Settings.HighlightTargetColor
        else
          v.Line1.Color = Esp.Settings.BoxesColor
          v.Line2.Color = Esp.Settings.BoxesColor
          v.Line3.Color = Esp.Settings.BoxesColor
          v.Line4.Color = Esp.Settings.BoxesColor
          v.Line5.Color = Esp.Settings.BoxesColor
          v.Line6.Color = Esp.Settings.BoxesColor
          v.Line7.Color = Esp.Settings.BoxesColor
          v.Line8.Color = Esp.Settings.BoxesColor
        end
        if v.PlayerTable.sleeping == true then
          v.Line1.Color = Esp.Settings.OtherBoxesColor;v.Line2.Color = Esp.Settings.OtherBoxesColor;v.Line3.Color = Esp.Settings.OtherBoxesColor;v.Line4.Color = Esp.Settings.OtherBoxesColor;v.Line5.Color = Esp.Settings.OtherBoxesColor;v.Line6.Color = Esp.Settings.OtherBoxesColor;v.Line7.Color = Esp.Settings.OtherBoxesColor;v.Line8.Color = Esp.Settings.OtherBoxesColor
        end
        if TeamTag == true then
          v.Line1.Color = Esp.Settings.OtherBoxesColorTeam;v.Line2.Color = Esp.Settings.OtherBoxesColorTeam;v.Line3.Color = Esp.Settings.OtherBoxesColorTeam;v.Line4.Color = Esp.Settings.OtherBoxesColorTeam;v.Line5.Color = Esp.Settings.OtherBoxesColorTeam;v.Line6.Color = Esp.Settings.OtherBoxesColorTeam;v.Line7.Color = Esp.Settings.OtherBoxesColorTeam;v.Line8.Color = Esp.Settings.OtherBoxesColorTeam
        end
      else
        v.Line1.Visible=false;v.Line2.Visible=false;v.Line3.Visible=false;v.Line4.Visible=false;v.Line5.Visible=false;v.Line6.Visible=false;v.Line7.Visible=false;v.Line8.Visible=false;v.BoxFilled.Visible = false
      end
      if OnScreen == true and Esp.Settings.Sleeping == true and Distance <= Esp.Settings.RenderDistance then
        if Character.Head.Nametag.tag.Text ~= "" then
          v.Sleeping.Text = Character:FindFirstChild("Head").Nametag.tag.Text
        else
          v.Sleeping.Text = "Enemy"
          if TeamTag == true then v.Sleeping.Text = "Friendly" end
          if v.PlayerTable.sleeping == true then v.Sleeping.Text = "Sleeping" end
        end
        if Esp.Settings.TeamCheck == true and TeamTag == false then  v.Sleeping.Visible = true elseif Esp.Settings.TeamCheck == true and TeamTag == true then v.Sleeping.Visible = false else v.Sleeping.Visible = true end
        if Esp.Settings.TargetSleepers == true and v.PlayerTable.sleeping == true then v.Sleeping.Visible = false end
        v.Sleeping.Outline=Esp.Settings.TextOutline;v.Sleeping.Color=Esp.Settings.SleepingColor;v.Sleeping.Size=math.max(math.min(math.abs(Esp.Settings.TextSize*scale),Esp.Settings.TextSize),Esp.Settings.MinTextSize);v.Sleeping.Color = Esp.Settings.SleepingColor;v.Sleeping.Font=Esp.Settings.TextFont;v.Sleeping.Position = Vector2.new(x,math.floor(y-h*0.5-v.Sleeping.TextBounds.Y))
        if Esp.Settings.HighlightTarget and Character == ccc then
          v.Sleeping.Color = Esp.Settings.HighlightTargetColor
        else
          v.Sleeping.Color = Esp.Settings.SleepingColor;
        end
        if v.PlayerTable.sleeping == true then v.Sleeping.Color = Esp.Settings.OtherSleepingColor end
        if TeamTag == true then v.Sleeping.Color = Esp.Settings.OtherSleepingColorTeam end
      else
        v.Sleeping.Visible=false
      end
      if OnScreen == true and Esp.Settings.Distances == true and Distance <= Esp.Settings.RenderDistance then
        if Esp.Settings.TeamCheck == true and TeamTag == false then v.Distance.Visible = true elseif Esp.Settings.TeamCheck == true and TeamTag == true then v.Distance.Visible = false else v.Distance.Visible = true end
        if Esp.Settings.TargetSleepers == true and v.PlayerTable.sleeping == true then v.Distance.Visible = false end
        v.Distance.Outline=Esp.Settings.TextOutline;v.Distance.Size = math.max(math.min(math.abs(Esp.Settings.TextSize*scale),Esp.Settings.TextSize),Esp.Settings.MinTextSize);v.Distance.Position=Vector2.new(x,math.floor(y+h*0.5));v.Distance.Color = Esp.Settings.DistanceColor;v.Distance.Text = tostring("["..math.floor(Distance)).."]";v.Distance.Font=Esp.Settings.TextFont
        if Esp.Settings.HighlightTarget and Character == ccc then
          v.Distance.Color = Esp.Settings.HighlightTargetColor
        else
          v.Distance.Color = Esp.Settings.DistanceColor;
        end
        if v.PlayerTable.sleeping == true then v.Distance.Color = Esp.Settings.OtherDistanceColor end
        if TeamTag == true then v.Distance.Color = Esp.Settings.OtherDistanceColorTeam end
      else
        v.Distance.Visible = false
      end
      if OnScreen == true and Esp.Settings.Tool == true and Distance <= Esp.Settings.RenderDistance then
        if Esp.Settings.TeamCheck == true and TeamTag == false then v.Tool.Visible = true elseif Esp.Settings.TeamCheck == true and TeamTag == true then v.Tool.Visible = false else v.Tool.Visible = true end
        if Esp.Settings.TargetSleepers == true and v.PlayerTable.sleeping == true then v.Tool.Visible = false end
        if Esp.Settings.Tool == true then v.Tool.Position=Vector2.new(x, math.floor(y+h*0.5)+v.Tool.TextBounds.Y) else v.Tool.Position=Vector2.new(x,math.floor(y+h*0.5)); end
        v.Tool.Text=Esp:CheckTools(v.PlayerTable);v.Tool.Outline=Esp.Settings.TextOutline;v.Tool.Size=math.max(math.min(math.abs(Esp.Settings.TextSize*scale),Esp.Settings.TextSize),Esp.Settings.MinTextSize);v.Tool.Color=Esp.Settings.ToolColor;v.Tool.Font=Esp.Settings.TextFont
        if Esp.Settings.HighlightTarget and Character == ccc then
          v.Tool.Color = Esp.Settings.HighlightTargetColor
        else
          v.Tool.Color = Esp.Settings.ToolColor;
        end
        if v.PlayerTable.sleeping == true then v.Tool.Color = Esp.Settings.OtherToolColor end
        if TeamTag == true then v.Tool.Color = Esp.Settings.OtherToolColorTeam end
      else
        v.Tool.Visible = false
      end
      local armorFolder = Character.Armor:FindFirstChildOfClass("Folder")
      if OnScreen == true and Esp.Settings.Armour == true and Distance <= Esp.Settings.RenderDistance and armorFolder then
        local armorName = armorFolder.Name
        if armorName == "WoodHelmet" or armorName == "WoodChestplate" or armorName == "WoodLeggings" then
          v.Armour.Text = "Wood Gear"
        elseif armorName == "RiotHelmet" or armorName == "RiotChestplate" or armorName == "RiotLeggings" then
          v.Armour.Text = "Riot Gear"
        elseif armorName == "IronHelmet" or armorName == "IronChestplate" or armorName == "IronLeggings" then
          v.Armour.Text = "Iron Gear"
        elseif armorName == "SteelHelmet" or armorName == "SteelChestplate" or armorName == "SteelLeggings" then
          v.Armour.Text = "Steel Gear"
        else
          v.Armour.Text = ""
        end
        if Esp.Settings.TeamCheck == true and TeamTag == false then v.Armour.Visible = true elseif Esp.Settings.TeamCheck == true and TeamTag == true then v.Armour.Visible = false else v.Armour.Visible = true end
        if Esp.Settings.TargetSleepers == true and v.PlayerTable.sleeping == true then v.Armour.Visible = false end
        v.Armour.Outline=Esp.Settings.TextOutline;v.Armour.Size = math.max(math.min(math.abs(Esp.Settings.TextSize*scale),Esp.Settings.TextSize),Esp.Settings.MinTextSize);v.Armour.Position=Vector2.new(math.floor(BoxPosX+w+v.Armour.TextBounds.X*1.30*0.5),BoxPosY+v.Armour.TextBounds.Y*1.85*0.5-((v.Armour.TextBounds.Y*2)*0.5));v.Armour.Color = Esp.Settings.ArmourColor;v.Armour.Font=Esp.Settings.TextFont
        v.Armour.Color = Esp.Settings.HighlightTargetColor
        if Esp.Settings.HighlightTarget and Character == ccc then
          v.Armour.Color = Esp.Settings.HighlightTargetColor
        else
          v.Armour.Color = Esp.Settings.ArmourColor;
        end
        if v.PlayerTable.sleeping == true then v.Armour.Color = Esp.Settings.OtherArmourColor end
        if TeamTag == true then v.Armour.Color = Esp.Settings.OtherArmourColorTeam end
      else
        v.Armour.Visible = false;
      end
      if OnScreen == true and Esp.Settings.Tracer == true and Distance <= Esp.Settings.RenderDistance then
        if Esp.Settings.TeamCheck == true and TeamTag == false then v.Tracer.Visible = true elseif Esp.Settings.TeamCheck == true and TeamTag == true then v.Tracer.Visible = false else v.Tracer.Visible = true end
        if Esp.Settings.TargetSleepers == true and v.PlayerTable.sleeping == true then v.Tracer.Visible = false end
        v.Tracer.Color = Esp.Settings.TracerColor;v.Tracer.Thickness=Esp.Settings.TracerThickness;v.Transparency=Esp.Settings.TracerTransparrency;
        if Esp.Settings.TracerFrom == "Bottom" then
          v.Tracer.From = Vector2.new(Camera.ViewportSize.X/2,Camera.ViewportSize.Y)
          v.Tracer.To = Vector2.new(x,y+h*0.5)
        elseif Esp.Settings.TracerFrom == "Middle" then
          v.Tracer.From = Vector2.new(Camera.ViewportSize.X/2,Camera.ViewportSize.Y/2)
          v.Tracer.To = Vector2.new(x,y)
        elseif Esp.Settings.TracerFrom == "Top" then
          v.Tracer.From = Vector2.new(Camera.ViewportSize.X / 2, 0)
          v.Tracer.To = Vector2.new(x,y-h*0.5)
        else
          v.Tracer.From = Vector2.new(Camera.ViewportSize.X/2,Camera.ViewportSize.Y/Camera.ViewportSize.Y)
          if Esp.Settings.Sleeping == true then
            v.Tracer.To = Vector2.new(x,(y-h)-v.Sleeping.TextBounds.Y*0.5)
          else
            v.Tracer.From = Vector2.new(Camera.ViewportSize.X/2,Camera.ViewportSize.Y)
            v.Tracer.To = Vector2.new(x,y-h*0.5)
          end
        end
        if Esp.Settings.HighlightTarget and Character == ccc then
          v.Tracer.Color = Esp.Settings.HighlightTargetColor
        else
          v.Tracer.Color = Esp.Settings.TracerColor;
        end
        if v.PlayerTable.sleeping == true then v.Tracer.Color = Esp.Settings.OtherTracerColor end
        if TeamTag == true then v.Tracer.Color = Esp.Settings.OtherTracerColorTeam end
      else
        v.Tracer.Visible = false
      end
      if OnScreen == true and Esp.Settings.ViewAngle == true and Distance <= Esp.Settings.RenderDistance then
        if Esp.Settings.TeamCheck == true and TeamTag == false then v.ViewAngle.Visible = true elseif Esp.Settings.TeamCheck == true and TeamTag == true then v.ViewAngle.Visible = false else v.ViewAngle.Visible = true end
        if Esp.Settings.TargetSleepers == true and v.PlayerTable.sleeping == true then v.ViewAngle.Visible = false end
        v.ViewAngle.Color = Esp.Settings.ViewAngleColor;v.ViewAngle.Thickness=Esp.Settings.ViewAngleThickness;v.Transparency=Esp.Settings.ViewAngleTransparrency;
        local headpos = Camera:WorldToViewportPoint(Character.Head.Position)
        local offsetCFrame = CFrame.new(0, 0, -4)
        v.ViewAngle.From = Vector2.new(headpos.X, headpos.Y)
        local value = math.clamp(1/Distance*100, 0.1, 1)
        local dir = Character.Head.CFrame:ToWorldSpace(offsetCFrame)
        offsetCFrame = offsetCFrame * CFrame.new(0, 0, 0.4)
        local dirpos = Camera:WorldToViewportPoint(Vector3.new(dir.X, dir.Y, dir.Z))
        if OnScreen == true then
          v.ViewAngle.To = Vector2.new(dirpos.X, dirpos.Y)
          offsetCFrame = CFrame.new(0, 0, -4)
        end
        if Esp.Settings.HighlightTarget and Character == ccc then
          v.ViewAngle.Color = Esp.Settings.HighlightTargetColor
        else
          v.ViewAngle.Color = Esp.Settings.ViewAngleColor;
        end
        if v.PlayerTable.sleeping == true then v.ViewAngle.Color = Esp.Settings.OtherViewAngleColor end
        if TeamTag == true then v.ViewAngle.Color = Esp.Settings.OtherViewAngleColorTeam end
      else
        v.ViewAngle.Visible = false
      end
      if OnScreen == true and Esp.Settings.HeadCircles == true and Distance <= Esp.Settings.RenderDistance then
        if Esp.Settings.TeamCheck == true and TeamTag == false then v.HeadCircles.Visible = true elseif Esp.Settings.TeamCheck == true and TeamTag == true then v.HeadCircles.Visible = false else v.HeadCircles.Visible = true end
        if Esp.Settings.TargetSleepers == true and v.PlayerTable.sleeping == true then v.HeadCircles.Visible = false end
        v.HeadCircles.Color = Esp.Settings.HeadCirclesColor;v.HeadCircles.Thickness=Esp.Settings.HeadCirclesThickness;v.Transparency=Esp.Settings.HeadCirclesTransparrency;
        local headpos = Camera:WorldToViewportPoint(Character.Head.Position)
        local Position,OnScreen = Camera:WorldToViewportPoint(Character:FindFirstChild("HumanoidRootPart").Position);
        if OnScreen == true then
          v.HeadCircles.Position = Vector2.new(headpos.X, headpos.Y)
          v.HeadCircles.Radius = 3
          v.HeadCircles.NumSides = 18
        end
        if Esp.Settings.HighlightTarget and Character == ccc then
          v.HeadCircles.Color = Esp.Settings.HighlightTargetColor
        else
          v.HeadCircles.Color = Esp.Settings.HeadCirclesColor;
        end
        if v.PlayerTable.sleeping == true then v.HeadCircles.Color = Esp.Settings.OtherHeadCirclesColor end
        if TeamTag == true then v.HeadCircles.Color = Esp.Settings.OtherHeadCirclesColorTeam end
      else
        v.HeadCircles.Visible = false
      end
    else
      v.Box.Visible=false;
      v.BoxOutline.Visible=false;
      v.BoxFilled.Visible=false;
      v.Tool.Visible=false;
      v.Armour.Visible=false;
      v.Distance.Visible=false;
      v.Sleeping.Visible=false;
      v.ViewAngle.Visible=false;
      v.HeadCircles.Visible=false;
      v.Tracer.Visible=false;
      v.Line1.Visible=false;v.Line2.Visible=false;v.Line3.Visible=false;v.Line4.Visible=false;v.Line5.Visible=false;v.Line6.Visible=false;v.Line7.Visible=false;v.Line8.Visible=false
    end
  end
end
local FovCircle = Functions:Draw("Circle",{Filled=Fov.Settings.FovFilled,Color=Fov.Settings.FovColor,Radius=Fov.Settings.FovSize,NumSides=12,Thickness=2,Transparency=Fov.Settings.FovTransparency,ZIndex=3,Visible=false})
local FovCircleOutline = Functions:Draw("Circle",{Filled=Fov.Settings.FovOutlineFilled,Color=Fov.Settings.FovOutlineColor,Radius=Fov.Settings.FovOutlineSize,NumSides=12,Thickness=2,Transparency=0,ZIndex=2.98,Visible=false})
local FovSnapline = Functions:Draw("Line",{Transparency=1,Thickness=2,Visible=false})
local CircleLine = Functions:Draw("Circle",{Color=Fov.Settings.CircleLineColor,Radius=6,NumSides=18,Thickness=1,Transparency=Fov.Settings.FovTransparency,Visible=false})
local PlayerUpdater = game:GetService("RunService").RenderStepped
local PlayerConnection = PlayerUpdater:Connect(function()
Esp:UpdateEsp()
end)
for i, v in pairs(getupvalues(getrenv()._G.modules.Player.GetPlayerModel)[1]) do
  if not table.find(cache,v) then
    table.insert(cache,v)
    Esp:CreateEsp(v)
  end
end
game:GetService("Workspace").ChildAdded:Connect(function(child)
if child:FindFirstChild("HumanoidRootPart") then
  for i, v in pairs(getupvalues(getrenv()._G.modules.Player.GetPlayerModel)[1]) do
    if not table.find(cache,v) then
      table.insert(cache,v)
      Esp:CreateEsp(v)
    end
  end
end
end)
function Functions:Draw(Type, Propities)
  if not Type and not Propities then
      return
  end
  local drawing = Drawing.new(Type)
  for i, v in pairs(Propities) do
      drawing[i] = v
  end
  table.insert(Esp.Drawings, drawing)
  return drawing
end
function Functions:GetToolNames()
  tbl = {}
  for i, v in pairs(game:GetService("ReplicatedStorage").HandModels:GetChildren()) do
      if not table.find(tbl, v.Name) then
          table.insert(tbl, v.Name)
      end
  end
  return tbl
end
function Esp:CheckTools(PlayerTable)
  if not PlayerTable then
      return
  end
  if PlayerTable.equippedItem and table.find(Functions:GetToolNames(), PlayerTable["equippedItem"].id) then
      return tostring(PlayerTable["equippedItem"].id)
  elseif
      PlayerTable.handModel
      and PlayerTable.handModel.Name
      and string.find(PlayerTable.handModel.Name, "Hammer")
  then
      return PlayerTable["handModel"].Name
  else
      return "Empty"
  end
end
function Esp:CreateEsp(PlayerTable)
  if not PlayerTable then
      return
  end
  local drawings = {}
  drawings.BoxOutline = Functions:Draw(
      "Square",
      {
          Thickness = 2,
          Filled = false,
          Transparency = 1,
          Color = Esp.Settings.BoxesOutlineColor,
          Visible = false,
          ZIndex = -1,
          Visible = false,
      }
  )
  drawings.Box = Functions:Draw(
      "Square",
      { Thickness = 1, Filled = false, Transparency = 1, Color = Esp.Settings.BoxesColor, Visible = false, ZIndex = 2, Visible = false }
  )
  drawings.Sleeping = Functions:Draw(
      "Text",
      {
          Text = "Nil",
          Font = Esp.Settings.TextFont,
          Size = Esp.Settings.TextSize,
          Center = true,
          Outline = Esp.Settings.TextOutline,
          Color = Esp.Settings.SleepingColor,
          ZIndex = 2,
          Visible = false,
      }
  )
  drawings.Armour = Functions:Draw(
      "Text",
      {
          Text = "Naked",
          Font = Esp.Settings.TextFont,
          Size = Esp.Settings.TextSize,
          Center = false,
          Outline = Esp.Settings.TextOutline,
          Color = Esp.Settings.ArmourColor,
          ZIndex = 2,
          Visible = false,
      }
  )
  drawings.Tool = Functions:Draw(
      "Text",
      {
          Text = "Nothing",
          Font = Esp.Settings.TextFont,
          Size = Esp.Settings.TextSize,
          Center = false,
          Outline = Esp.Settings.TextOutline,
          Color = Esp.Settings.ToolColor,
          ZIndex = 2,
          Visible = false,
      }
  )
  drawings.ViewAngle = Functions:Draw(
      "Line",
      {
          Thickness = Esp.Settings.ViewAngleThickness,
          Transparency = Esp.Settings.ViewAngleTransparrency,
          Color = Esp.Settings.ViewAngleColor,
          ZIndex = 2,
          Visible = false,
      }
  )
  drawings.Tracer = Functions:Draw(
      "Line",
      { Thickness = Esp.Settings.TracerThickness, Transparency = 1, Color = Esp.Settings.TracerColor, ZIndex = 2, Visible = false }
  )
  drawings.PlayerTable = PlayerTable
  Esp.Players[PlayerTable.model] = drawings
end
function Esp:RemoveEsp(PlayerTable)
  if not PlayerTable and PlayerTable.model ~= nil then
      return
  end
  esp = Esp.Players[PlayerTable.model]
  if not esp then
      return
  end
  for i, v in pairs(esp) do
      if not type(v) == "table" then
          v:Remove()
      end
  end
  Esp.Players[PlayerTable.model] = nil
end

function Esp:UpdateEsp()
  for i, v in pairs(Esp.Players) do
      local Character = i
      local Position, OnScreen = Camera:WorldToViewportPoint(Character:GetPivot().Position)
      local scale = 1 / (Position.Z * math.tan(math.rad(Camera.FieldOfView * 0.5)) * 2) * 100
      local w, h = math.floor(40 * scale), math.floor(55 * scale)
      local x, y = math.floor(Position.X), math.floor(Position.Y)
      local Distance = (CharcaterMiddle:GetPivot().Position - Character:GetPivot().Position).Magnitude
      local BoxPosX, BoxPosY = math.floor(x - w * 0.5), math.floor(y - h * 0.5)
      local offsetCFrame = CFrame.new(0, 0, -4)
      if Character and Character:FindFirstChild("HumanoidRootPart") and Character:FindFirstChild("Head") then
          local TeamTag = Character.Head.Teamtag.Enabled
          if OnScreen == true and Esp.Settings.Boxes == true and Distance <= Esp.Settings.RenderDistance then
              if Esp.Settings.TeamCheck == true and TeamTag == false then
                  v.BoxOutline.Visible = Esp.Settings.BoxesOutline
                  v.Box.Visible = true
              elseif Esp.Settings.TeamCheck == true and TeamTag == true then
                  v.BoxOutline.Visible = false
                  v.Box.Visible = false
              else
                  v.BoxOutline.Visible = Esp.Settings.BoxesOutline
                  v.Box.Visible = true
              end
              if Esp.Settings.TargetSleepers == true and v.PlayerTable.sleeping == true then
                  v.BoxOutline.Visible = false
                  v.Box.Visible = false
              end
              v.BoxOutline.Position = Vector2.new(BoxPosX, BoxPosY)
              v.BoxOutline.Size = Vector2.new(w, h)
              v.Box.Position = Vector2.new(BoxPosX, BoxPosY)
              v.Box.Size = Vector2.new(w, h)
              v.Box.Color = Esp.Settings.BoxesColor
              v.BoxOutline.Color = Esp.Settings.BoxesOutlineColor
          else
              v.BoxOutline.Visible = false
              v.Box.Visible = false
          end
          if OnScreen == true and Esp.Settings.Sleeping == true and Distance <= Esp.Settings.RenderDistance then
              if v.PlayerTable.sleeping == true then
                  v.Sleeping.Text = "Sleeping"
              else
                  v.Sleeping.Text = "Awake"
              end
              if Esp.Settings.TeamCheck == true and TeamTag == false then
                  v.Sleeping.Visible = true
              elseif Esp.Settings.TeamCheck == true and TeamTag == true then
                  v.Sleeping.Visible = false
              else
                  v.Sleeping.Visible = true
              end
              if Esp.Settings.TargetSleepers == true and v.PlayerTable.sleeping == true then
                  v.Sleeping.Visible = false
              end
              v.Sleeping.Outline = Esp.Settings.TextOutline
              v.Sleeping.Color = Esp.Settings.SleepingColor
              v.Sleeping.Size = math.max(
                  math.min(math.abs(Esp.Settings.TextSize * scale), Esp.Settings.TextSize),
                  Esp.Settings.MinTextSize
              )
              v.Sleeping.Color = Esp.Settings.SleepingColor
              v.Sleeping.Font = Esp.Settings.TextFont
              v.Sleeping.Position = Vector2.new(x, math.floor(y - h * 0.5 - v.Sleeping.TextBounds.Y))
          else
              v.Sleeping.Visible = false
          end
          if OnScreen == true and Esp.Settings.Distances == true and Distance <= Esp.Settings.RenderDistance then
              if Esp.Settings.TeamCheck == true and TeamTag == false then
                  v.Sleeping.Visible = true
              elseif Esp.Settings.TeamCheck == true and TeamTag == true then
                  v.Sleeping.Visible = false
              else
                  v.Sleeping.Visible = true
              end
              if Esp.Settings.TargetSleepers == true and v.PlayerTable.sleeping == true then
                  v.Sleeping.Visible = false
              end

              if Esp.Settings.Sleeping == false then
                  v.Sleeping.Text = math.floor(Distance) .. "s"
              else
                  v.Sleeping.Text = v.Sleeping.Text .. " | " .. math.floor(Distance) .. "s"
              end
              v.Sleeping.Outline = Esp.Settings.TextOutline
              v.Sleeping.Color = Esp.Settings.SleepingColor
              v.Sleeping.Size = math.max(
                  math.min(math.abs(Esp.Settings.TextSize * scale), Esp.Settings.TextSize),
                  Esp.Settings.MinTextSize
              )
              v.Sleeping.Color = Esp.Settings.SleepingColor
              v.Sleeping.Font = Esp.Settings.TextFont
              v.Sleeping.Position = Vector2.new(x, math.floor(y - h * 0.5 - v.Sleeping.TextBounds.Y))
          else
              v.Sleeping.Visible = false
          end
          if OnScreen == true and Esp.Settings.Tool == true and Distance <= Esp.Settings.RenderDistance then
              if Esp.Settings.TeamCheck == true and TeamTag == false then
                  v.Tool.Visible = true
              elseif Esp.Settings.TeamCheck == true and TeamTag == true then
                  v.Tool.Visible = false
              else
                  v.Tool.Visible = true
              end
              if Esp.Settings.TargetSleepers == true and v.PlayerTable.sleeping == true then
                  v.Tool.Visible = false
              end
              v.Tool.Position = Vector2.new(
                  math.floor((BoxPosX + w) + v.Tool.TextBounds.X / 10),
                  BoxPosY + v.Tool.TextBounds.Y * 1.55 * 0.5 - ((v.Tool.TextBounds.Y * 2) * 0.5) + v.Tool.TextBounds.Y
              )
              v.Tool.Text = Esp:CheckTools(v.PlayerTable)
              v.Tool.Outline = Esp.Settings.TextOutline
              v.Tool.Size = math.max(
                  math.min(math.abs(Esp.Settings.TextSize * scale), Esp.Settings.TextSize),
                  Esp.Settings.MinTextSize
              )
              v.Tool.Color = Esp.Settings.ToolColor
              v.Tool.Font = Esp.Settings.TextFont
          else
              v.Tool.Visible = false
          end
          if OnScreen == true and Esp.Settings.Armour == true and Distance <= Esp.Settings.RenderDistance then
              if Character.Armor:FindFirstChildOfClass("Folder") then
                  v.Armour.Text = "Armoured"
              else
                  v.Armour.Text = "Naked"
              end
              if Esp.Settings.TeamCheck == true and TeamTag == false then
                  v.Armour.Visible = true
              elseif Esp.Settings.TeamCheck == true and TeamTag == true then
                  v.Armour.Visible = false
              else
                  v.Armour.Visible = true
              end
              if Esp.Settings.TargetSleepers == true and v.PlayerTable.sleeping == true then
                  v.Armour.Visible = false
              end
              v.Armour.Outline = Esp.Settings.TextOutline
              v.Armour.Size = math.max(
                  math.min(math.abs(Esp.Settings.TextSize * scale), Esp.Settings.TextSize),
                  Esp.Settings.MinTextSize
              )
              v.Armour.Position = Vector2.new(
                  math.floor((BoxPosX + w) + v.Armour.TextBounds.X / 10),
                  BoxPosY + v.Armour.TextBounds.Y * 1.55 * 0.5 - ((v.Armour.TextBounds.Y * 2) * 0.5)
              )
              v.Armour.Color = Esp.Settings.ArmourColor
              v.Armour.Font = Esp.Settings.TextFont
          else
              v.Armour.Visible = false
          end
          if OnScreen == true and Esp.Settings.Tracer == true and Distance <= Esp.Settings.RenderDistance then
              if Esp.Settings.TeamCheck == true and TeamTag == false then
                  v.Tracer.Visible = true
              elseif Esp.Settings.TeamCheck == true and TeamTag == true then
                  v.Tracer.Visible = false
              else
                  v.Tracer.Visible = true
              end
              if Esp.Settings.TargetSleepers == true and v.PlayerTable.sleeping == true then
                  v.Tracer.Visible = false
              end
              v.Tracer.Color = Esp.Settings.TracerColor
              v.Tracer.Thickness = Esp.Settings.TracerThickness
              v.Transparency = Esp.Settings.TracerTransparrency
              if Esp.Settings.TracerFrom == "Bottom" then
                  v.Tracer.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
                  v.Tracer.To = Vector2.new(x, y + h * 0.5)
              elseif Esp.Settings.TracerFrom == "Middle" then
                  v.Tracer.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                  v.Tracer.To = Vector2.new(x, y)
              else
                  v.Tracer.From =
                      Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / Camera.ViewportSize.Y)
                  if Esp.Settings.Sleeping == true then
                      v.Tracer.To = Vector2.new(x, (y - h) - v.Sleeping.TextBounds.Y * 0.5)
                  else
                      v.Tracer.To = Vector2.new(x, y - h * 0.5)
                  end
              end
          else
              v.Tracer.Visible = false
          end
          if OnScreen == true and Esp.Settings.ViewAngle == true and Distance <= Esp.Settings.RenderDistance then
              if Esp.Settings.TeamCheck == true and TeamTag == false then
                  v.ViewAngle.Visible = true
              elseif Esp.Settings.TeamCheck == true and TeamTag == true then
                  v.ViewAngle.Visible = false
              else
                  v.ViewAngle.Visible = true
              end
              if Esp.Settings.TargetSleepers == true and v.PlayerTable.sleeping == true then
                  v.ViewAngle.Visible = false
              end
              v.ViewAngle.Color = Esp.Settings.ViewAngleColor
              v.ViewAngle.Thickness = Esp.Settings.ViewAngleThickness
              v.Transparency = Esp.Settings.ViewAngleTransparrency
              local headpos = Camera:WorldToViewportPoint(Character.Head.Position)
              local offsetCFrame = CFrame.new(0, 0, -4)
              v.ViewAngle.From = Vector2.new(headpos.X, headpos.Y)
              local value = math.clamp(1 / Distance * 100, 0.1, 1)
              local dir = Character.Head.CFrame:ToWorldSpace(offsetCFrame)
              offsetCFrame = offsetCFrame * CFrame.new(0, 0, 0.4)
              local dirpos = Camera:WorldToViewportPoint(Vector3.new(dir.X, dir.Y, dir.Z))
              if OnScreen == true then
                  v.ViewAngle.To = Vector2.new(dirpos.X, dirpos.Y)
                  offsetCFrame = CFrame.new(0, 0, -4)
              end
          else
              v.ViewAngle.Visible = false
          end
      else
          v.Box.Visible = false
          v.BoxOutline.Visible = false
          v.Tool.Visible = false
          v.Armour.Visible = false
          v.Sleeping.Visible = false
          v.ViewAngle.Visible = false
          v.Tracer.Visible = false
      end
  end
end
local SilentTabbox = Tabs.Main:AddLeftTabbox()
local SilentTab = SilentTabbox:AddTab('Silent Aim')
local FovTab = SilentTabbox:AddTab('Settings')


--* Silent Aim *--

SilentTab:AddToggle('SilentAim',{Text='Enable',Default=false}):AddKeyPicker('SilentKey', {Default='MB2',SyncToggleState=true,Mode='Hold',Text='Silent Aim',NoUI=false}):OnChanged(function(Value)
Combat.Settings.SilentEnabled = Value
end)

SilentTab:AddSlider('HitChance', {Text='Aim Distance',Default=1000,Min=0,Max=3000,Rounding=0,Compact=true,Suffix=""}):OnChanged(function(Value)
Combat.Settings.RenderDistance = Value
end)

SilentTab:AddToggle('Snapline',{Text='Target Snapline',Default=false}):AddColorPicker('SnaplineColor',{Default=Color3.fromRGB(255, 255, 255),Title='Color'})

SilentTab:AddDropdown('SilentHitpart', {Values = {"Head", "Torso"}, Default = 1, Multi = false, Text = 'Part'}):OnChanged(function(Value)
    Combat.Settings.SilentAimPart = Value
    end)

SilentTab:AddDivider()

SilentTab:AddToggle('Fov',{Text='Fov Enable',Default=false}):AddColorPicker('FovColor',{Default=Color3.fromRGB(255, 255, 255),Title='Color'})
SilentTab:AddSlider('FovSize', {Text='Fov Size',Default=250,Min=0,Max=1000,Rounding=0,Compact=true}):OnChanged(function(Value)
Fov.Settings.FovSize = Value;FovCircle.Radius = Value
Fov.Settings.FovOutlineSize = Value;FovCircleOutline.Radius = Value
end)
SilentTab:AddSlider('Transparency', {Text='Fov Transparency',Default=1,Min=0,Max=1,Rounding=1,Compact=true,Suffix=""}):OnChanged(function(Value)
Fov.Settings.FovTransparency = Value;FovCircle.Transparency = Value
end)





--* Fov Circle *-
FovTab:AddToggle('SleeperCheck',{Text='Sleeper Check',Default=false}):OnChanged(function(Value)
    Combat.Settings.SleeperCheck = Value
    end)

FovTab:AddDropdown('SnaplinePosition', {Values = {"Top","Middle","Bottom"},Default = 2,Multi = false,Text = 'Snapline Position'}):OnChanged(function(Value)
    Fov.Settings.SnaplinePosition = Value
    end)

FovTab:AddDropdown('FovPosition', {Values = {"Screen","Mouse"},Default = 1,Multi = false,Text = 'Fov Position'}):OnChanged(function(Value)
Fov.Settings.FovPosition = Value
Fov.Settings.FovOutlinePosition = Value
end)

game:GetService("RunService").RenderStepped:Connect(function()

if Functions:GetClosest() ~= nil then
local p,t = Functions:GetClosest()
FovCircle.Color = Fov.Settings.FovColor
local Position,OnScreen = Camera:WorldToViewportPoint(Functions:GetClosest()[Combat.Settings.SilentAimPart]:GetPivot().p+Functions:Predict());
if Fov.Settings.FovHighlight == true and Functions:GetClosest().Head.Teamtag.Enabled == false and OnScreen == true then
  FovCircle.Color = Fov.Settings.FovHighlightColor
else
  FovCircle.Color=Fov.Settings.FovColor
end
else
FovCircle.Color = Fov.Settings.FovColor
end
if Functions:GetClosest() ~= nil and Toggles.Snapline.Value == true then
local p,t = Functions:GetClosest()
FovSnapline.Visible = true
CircleLine.Visible = true
local Position,OnScreen = Camera:WorldToViewportPoint(Functions:GetClosest()[Combat.Settings.SilentAimPart]:GetPivot().p+Functions:Predict());
if Combat.Settings.TeamCheck == true and Functions:GetClosest().Head.Teamtag.Enabled == false and OnScreen == true then
  FovSnapline.To = Position
  CircleLine.Position = Position
elseif OnScreen == true then
  FovSnapline.To = Position
  CircleLine.Position = Position
end
else
FovSnapline.Visible = false
CircleLine.Visible = false
end
if Functions:GetClosest() ~= nil then
local p,t = Functions:GetClosest()
CircleLine.Visible = true
local Position,OnScreen = Camera:WorldToViewportPoint(Functions:GetClosest()[Combat.Settings.SilentAimPart]:GetPivot().p+Functions:Predict());
if Combat.Settings.TeamCheck == true and Functions:GetClosest().Head.Teamtag.Enabled == false and OnScreen == true then
  CircleLine.Position = Position
elseif OnScreen == true then
  CircleLine.Position = Position
end
else
CircleLine.Visible = false
end
Fov.Settings.RealFovSize=FovCircle.Radius
Fov.Settings.RealFovOutlineSize=FovCircle.Radius
if Fov.Settings.Dynamic == true then
local set = Fov.Settings.FovSize * ((Fov.Settings.FovSize-Camera.FieldOfView)/70 + 0.14) + 17.5
local set2 = Fov.Settings.FovOutlineSize * ((Fov.Settings.FovOutlineSize-Camera.FieldOfView)/70 + 0.14) + 17.5
FovCircle.Radius = set
FovCircleOutline.Radius = set
else
FovCircle.Radius=Fov.Settings.FovSize
FovCircleOutline.Radius=Fov.Settings.FovOutlineSize
end
if Fov.Settings.FovPosition == "To Screen" then
FovCircle.Position = Vector2.new(Camera.ViewportSize.X/2,Camera.ViewportSize.Y/2)
FovCircleOutline.Position = Vector2.new(Camera.ViewportSize.X/2,Camera.ViewportSize.Y/2)
else
local MousePos = Camera.WorldToViewportPoint(Camera,game.Players.LocalPlayer:GetMouse().Hit.p)
FovCircle.Position = Vector2.new(MousePos.X,MousePos.Y)
FovCircleOutline.Position = Vector2.new(MousePos.X,MousePos.Y)
end
if Fov.Settings.SnaplinePosition == "Bottom" then
FovSnapline.From=Vector2.new(Camera.ViewportSize.X/2,Camera.ViewportSize.Y)
elseif Fov.Settings.SnaplinePosition == "Middle" then
FovSnapline.From=Vector2.new(Camera.ViewportSize.X/2,Camera.ViewportSize.Y/2)
elseif Fov.Settings.SnaplinePosition == "Top" then
FovSnapline.From=Vector2.new(Camera.ViewportSize.X / 2, 0)
end
end)

--// Fov Switches
Toggles.Fov:OnChanged(function(Value)
Fov.Settings.FovEnabled = Value
FovCircle.Visible = Value
Fov.Settings.FovOutlineEnabled = Value
FovCircleOutline.Visible = Value
end)
Options.FovColor:OnChanged(function(Value)
Fov.Settings.FovColor = Value
FovCircle.Color = Value
end)

--// Silent Aim Switches
Toggles.Snapline:OnChanged(function(Value)
Fov.Settings.Snapline = Value
FovSnapline.Visible = Value
end)
Options.SnaplineColor:OnChanged(function(Value)
Fov.Settings.SnaplineColor = Value
FovSnapline.Color=Value
end)

--// Silent Aim
local oldFunctionGun; oldFunctionGun = hookfunction(getupvalues(getrenv()._G.modules.FPS.ToolControllers.RangedWeapon.PlayerFire)[1],function(...)
args = {...}
local Player,PlayerTable = Functions:GetClosest()
if Combat.Settings.SilentEnabled == true and Player ~= nil and (CharcaterMiddle:GetPivot().Position-Player:GetPivot().Position).Magnitude <= Combat.Settings.RenderDistance and math.random(0,100) <= Combat.Settings.SilentHitChance then
if Combat.Settings.TeamCheck == true and Player.Head.Teamtag.Enabled == false then
if Combat.Settings.SleeperCheck == true and PlayerTable.sleeping == false then
args[1] = CFrame.lookAt(args[1].Position,Player[Combat.Settings.SilentAimPart]:GetPivot().p+Functions:Predict())
else
args[1] = CFrame.lookAt(args[1].Position,Player[Combat.Settings.SilentAimPart]:GetPivot().p+Functions:Predict())
end
else
if Combat.Settings.SleeperCheck == true and PlayerTable.sleeping == false then
args[1] = CFrame.lookAt(args[1].Position,Player[Combat.Settings.SilentAimPart]:GetPivot().p+Functions:Predict())
else
args[1] = CFrame.lookAt(args[1].Position,Player[Combat.Settings.SilentAimPart]:GetPivot().p+Functions:Predict())
end
end
end
return oldFunctionGun(unpack(args))
end)

local oldFunction; oldFunction = hookfunction(getupvalues(getrenv()._G.modules.FPS.ToolControllers.BowSpecial.PlayerFire)[4],function(...)
args = {...}
local Player,PlayerTable = Functions:GetClosest()
if Combat.Settings.SilentEnabled == true and Player ~= nil and (CharcaterMiddle:GetPivot().Position-Player:GetPivot().Position).Magnitude <= Combat.Settings.RenderDistance and math.random(0,100) <= Combat.Settings.SilentHitChance then
if Combat.Settings.TeamCheck == true and Player.Head.Teamtag.Enabled == false then
if Combat.Settings.SleeperCheck == true and PlayerTable.sleeping == false then
args[1] = CFrame.lookAt(args[1].Position,Player[Combat.Settings.SilentAimPart]:GetPivot().p+Functions:Predict())
else
args[1] = CFrame.lookAt(args[1].Position,Player[Combat.Settings.SilentAimPart]:GetPivot().p+Functions:Predict())
end
else
if Combat.Settings.SleeperCheck == true and PlayerTable.sleeping == false then
args[1] = CFrame.lookAt(args[1].Position,Player[Combat.Settings.SilentAimPart]:GetPivot().p+Functions:Predict())
else
args[1] = CFrame.lookAt(args[1].Position,Player[Combat.Settings.SilentAimPart]:GetPivot().p+Functions:Predict())
end
end
end
return oldFunction(unpack(args))
end)
--Connections
local PlayerUpdater = game:GetService("RunService").RenderStepped
local PlayerConnection = PlayerUpdater:Connect(function()
  Esp:UpdateEsp()
end)

--Init Functions

for i, v in pairs(getupvalues(getrenv()._G.modules.Player.GetPlayerModel)[1]) do
  if not table.find(cache, v) then
      table.insert(cache, v)
      Esp:CreateEsp(v)
  end
end

game:GetService("Workspace").ChildAdded:Connect(function(child)
  if child:FindFirstChild("HumanoidRootPart") then
      for i, v in pairs(getupvalues(getrenv()._G.modules.Player.GetPlayerModel)[1]) do
          if not table.find(cache, v) then
              Esp:CreateEsp(v)
              table.insert(cache, v)
          end
      end
  end
end)


local FieldOfViewTabBox = Tabs.Main:AddRightTabbox('Field of View')
local FieldOfViewTab = FieldOfViewTabBox:AddTab('Field of View')

--* Field Of View *--

local FieldOfViewEnabled = false
local FieldOfViewValue = 70
local CurrentSliderValue3 = 70
game:GetService("RunService").RenderStepped:Connect(function()
local fovFunc = nil
for i,v in pairs(getreg()) do
if type(v) == "function" and getfenv(v).script.Name == "Camera" and #getupvalues(v) >= 18 then
fovFunc = v
end
end
setupvalue(fovFunc,18,FieldOfViewValue)
end)

FieldOfViewTab:AddToggle('FieldOfView', { Text = 'Enable', Default = false }):AddKeyPicker('fieldofviewkey', { Default = 'Non', SyncToggleState = true, Mode = 'Toggle', Text = 'field of view', NoUI = true }):OnChanged(function(value)
FieldOfViewEnabled = value
if not FieldOfViewEnabled then
FieldOfViewValue = 70
else
FieldOfViewValue = CurrentSliderValue3
end
end)

FieldOfViewTab:AddSlider('FieldOfViewSlider', { Text = 'Intensity', Suffix = "", Default = 70, Min = 10, Max = 120, Rounding = 0, Compact = true }):OnChanged(function(sliderValue)
CurrentSliderValue3 = sliderValue
if FieldOfViewEnabled then
FieldOfViewValue = sliderValue
end
end)


--// COMBAT \\--
local TabBox = Tabs.Main:AddRightTabbox()
local ExploitsTab = TabBox:AddTab('Misc Modification')


local longneck = {
  LongNeckEnabled = false,
  UpperLimitDefault = 3,
  LowerLimitDefault = 1.75,
  CurrentSliderValue = 1.75,
  }
  
  ExploitsTab:AddToggle('LongNeck', {Text = 'LongNeck', Default = false, Tooltip}):AddKeyPicker('LongNeckKey', {Default = 'Non', SyncToggleState = true, Mode = 'Toggle', Text = 'Long Neck', NoUI = false}):OnChanged(function(value)
  longneck.LongNeckEnabled = value
  if not longneck.LongNeckEnabled then
  game:GetService("Workspace").Ignore.LocalCharacter.Bottom.PrismaticConstraint.UpperLimit = longneck.UpperLimitDefault
  game:GetService("Workspace").Ignore.LocalCharacter.Bottom.PrismaticConstraint.LowerLimit = longneck.LowerLimitDefault
  else
  game:GetService("Workspace").Ignore.LocalCharacter.Bottom.PrismaticConstraint.UpperLimit = longneck.CurrentSliderValue
  game:GetService("Workspace").Ignore.LocalCharacter.Bottom.PrismaticConstraint.LowerLimit = longneck.CurrentSliderValue
  end
  end)
  
  ExploitsTab:AddSlider('HeightChangerSlider', {Text = 'Height', Suffix = "", Default = 4, Min = 1, Max = 10; Rounding = 1, Compact = true}):OnChanged(function(Value)
  longneck.CurrentSliderValue = Value
  if longneck.LongNeckEnabled then
  game:GetService("Workspace").Ignore.LocalCharacter.Bottom.PrismaticConstraint.LowerLimit = Value
  game:GetService("Workspace").Ignore.LocalCharacter.Bottom.PrismaticConstraint.UpperLimit = Value
  end
  end)

  local Misc = {
  Settings = {
  JumpShoot = false,
  NoADS = false,
  }
  }
  
  ExploitsTab:AddToggle('JumpShoot',{Text='Jump Shoot',Default=false}):OnChanged(function(Value)
  Misc.Settings.JumpShoot = Value
  end)
  local oldIsGrounded;oldIsGrounded = hookfunction(getrenv()._G.modules.Character.IsGrounded,function(...)
  if Misc.Settings.JumpShoot == true then
  return true
  else
  return oldIsGrounded(...)
  end
  end)
  
  ExploitsTab:AddToggle('NoADS',{Text='No Ads',Default=false}):OnChanged(function(Value)
  Misc.Settings.NoADS = Value
  end)
  local oldNoADS;oldNoADS = hookfunction(getrenv()._G.modules.Camera.SetVMAimingOffset,function(...)
  if Misc.Settings.NoADS == true then
  return true
  else
  return oldNoADS(...)
  end
  end)
  
  local NoSway = false
  ExploitsTab:AddToggle('NoSway',{Text='No Sway',Default=false}):OnChanged(function(Value)
  NoSway = Value
  end)
  local NoSwayHook;NoSwayHook = hookfunction(getrenv()._G.modules.Camera.SetSwaySpeed,function(...)
  local args = {...}
  if NoSway == true then
  args[1] = 0
  return NoSwayHook(unpack(args))
  end
  return NoSwayHook(...)
  end)
  
  ExploitsTab:AddDivider()
  
  ExploitsTab:AddToggle('ArrowGun', {Text = 'Bullet Tracers',Default = false}):OnChanged(function(ArrowValue)
  for I, V in pairs(getgc(true)) do
  if type(V) == "table" and rawget(V, "TracerPart") then
  if ArrowValue == true then
    V.TracerPart = "Arrow"
  elseif ArrowValue == false then
    V.TracerPart = "Bullet"
  end
  end
  end
  end)
  





local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')

MenuGroup:AddButton('Unload', function() Library:Unload() end)
MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'Insert', NoUI = true, Text = 'Menu keybind' })

Library.ToggleKeybind = Options.MenuKeybind 


ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)


SaveManager:IgnoreThemeSettings()


SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })


ThemeManager:SetFolder('MyScriptHub')
SaveManager:SetFolder('MyScriptHub/specific-game')


SaveManager:BuildConfigSection(Tabs['UI Settings'])


ThemeManager:ApplyToTab(Tabs['UI Settings'])

SaveManager:LoadAutoloadConfig()
