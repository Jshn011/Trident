getgenv()._SilentAim = {
    Enabled = true,
    Silent_Target = nil,
    X_Offset = 0,
    Y_Offset = 0,
    MaxDistance = 500,
}

getgenv().ASSettings = {
    AimType = "To Cursor",
    AimDis = 200,
    AimSleepers = false,
    VisibleCheck = false,
    Prediction = false,
}

local UserInputService = game:GetService("UserInputService")

local function onInputBegan(input)
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        Silent_Hold = true
    end
end

local function onInputEnded(input)
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        Silent_Hold = false
    end
end

UserInputService.InputBegan:Connect(onInputBegan)
UserInputService.InputEnded:Connect(onInputEnded)

local anticam
anticam = hookmetamethod(game, "__index", newcclosure(function(...)
    local self, k = ...
    if not checkcaller() and k == "CFrame" and self.Name == "Camera" and self == Camera then
        return _Camera.GetCFrame()
    end

    return anticam(...)
end))

local antihitbox
antihitbox = hookmetamethod(game, "__index", newcclosure(function(...)
    local self, k = ...

    if not checkcaller() and k == "Size" and self.Name == "Head" then
        return Vector3.new(1.9362000226974487, 0.9681000113487244, 0.9681000113487244)
    end

    return antihitbox(...)
end))

-- Game Globals
local _Network = getrenv()._G.modules.Network;
local _Player = getrenv()._G.modules.Player;
local _Character = getrenv()._G.modules.Character;
local _Camera = getrenv()._G.modules.Camera;

-- Locals
local Players = game:GetService("Players");
local LocalPlayer = Players.LocalPlayer;
local Camera = game:GetService("Workspace").Camera;
local Mouse = LocalPlayer:GetMouse();

-- Sleeping Check
function IsSleeping(head)
    if Model and Model:FindFirstChild("AnimationController") and Model.AnimationController:FindFirstChild("Animator") then
        for i,v in pairs(Model.AnimationController.Animator:GetPlayingAnimationTracks()) do
            if v.Animation.AnimationId == "rbxassetid://12501841745" then
                return true
            else
                return false
            end
        end
    end
end

function GetDistance(Vector3)
    return (game:GetService("Workspace").Ignore.LocalCharacter.Middle:GetPivot().p - Vector3).Magnitude
end

-- Get Closest to mouse
function getClosestPlayerToCursor()
    local closestPlayer = nil;
    local shortestDistance = ASSettings["AimDis"];

    for i, v in pairs(game:GetService("Workspace"):GetChildren()) do
        if v:IsA("Model") and v:FindFirstChild("HumanoidRootPart") and v.Name ~= "Player" then
            if v.PrimaryPart ~= nil and v:FindFirstChild("Head") then
                if (IsSleeping(v.Head) and not ASSettings["AimSleepers"]) then return nil end

                local pos = Camera.WorldToViewportPoint(Camera, v.PrimaryPart.Position)
                local magnitude = (Vector2.new(pos.X, pos.Y) - Vector2.new(Mouse.X, Mouse.Y)).magnitude
                if magnitude <= shortestDistance and GetDistance(v.PrimaryPart.Position) <= _SilentAim.MaxDistance then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            end
        end
    end

    return closestPlayer
end

-- Get Closest to LocalPlayer
function getClosestPlayerToPlayer()
    local closestPlayer = nil;
    local shortestDistance = ASSettings["AimDis"];

    for i, v in pairs(game:GetService("Workspace"):GetChildren()) do
        if v:IsA("Model") and v:FindFirstChild("HumanoidRootPart") and v.Name ~= "Player" then
            if v.PrimaryPart ~= nil and v:FindFirstChild("Head") then
                if(IsSleeping(v.Head) and not ASSettings["AimSleepers"]) then
                    return nil;
                end

                local magnitude = (_Character.character.Middle.Position - v.PrimaryPart.Position).magnitude
                if magnitude <= shortestDistance and GetDistance(v.PrimaryPart.Position) <= _SilentAim.MaxDistance then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            end
        end
    end
    return closestPlayer
end

local Circle = Drawing.new("Circle");Circle.Visible = false;Circle.Position=Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
Circle.Radius = ASSettings["AimDis"];Circle.Thickness = 2;Circle.Transparency = 1;Circle.NumSides = 100;Circle.Visible = true;
local Txt = Drawing.new("Text");Txt.Visible = false;Txt.Text="0 Studs";Txt.Size=15;Txt.Font=1;Txt.Center=true;Txt.Outline=true
print()
Txt.Position=Vector2.new(Circle.Position.X,Circle.Position.Y+(Circle.Radius+Txt.TextBounds.Y));
Txt.Visible = true
game:GetService("RunService").Heartbeat:Connect(function()
        if targetPos and _SilentAim.Enabled and _SilentAim.Silent_Target and GetDistance(targetPos) <= _SilentAim.MaxDistance then
            local targetPos = Camera:WorldToViewportPoint(_SilentAim.Silent_Target.Position)
            Circle.Position = Vector2.new(targetPos.X, targetPos.Y)
        else
            Circle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
            Txt.Position=Vector2.new(Circle.Position.X,Circle.Position.Y+(Circle.Radius+Txt.TextBounds.Y));
        end
end)

local Line = Drawing.new("Line");Line.Visible = false;Line.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2);Line.To=Line.From;Line.Thickness = 2;Line.Transparency = 1;Line.Visible = true

local hue = 0

-- Replace Camera function
local OrginalGetCFrame = _Camera.GetCFrame;

_Camera.GetCFrame = function()
    if _SilentAim["Enabled"] and _SilentAim["Silent_Target"] then
        return CFrame.new(OrginalGetCFrame().p, _SilentAim["Silent_Target"].Position + Vector3.new((_SilentAim["X_Offset"]), (_SilentAim["Y_Offset"]), 0.001));
    else
        return OrginalGetCFrame();
    end
end


game:GetService("RunService").Stepped:Connect(function()
    if Silent_Hold and _SilentAim["Enabled"] then
        local Target;
        if ASSettings["AimType"] == "To Cursor" then
            Target = getClosestPlayerToCursor();
        else
            Target = getClosestPlayerToPlayer();
        end
        if Target then
            local Head = Target:FindFirstChild("Head");
            if Head then
                local oldx, oldy = Head.Position.X, Head.Position.Y;
                
                -- Add some randomness to aim adjustments
                local randomnessFactor = 1 -- You can adjust this value to control the level of randomness
                local randomXOffset = (_SilentAim["X_Offset"] - (math.random() - 0.5) * randomnessFactor)
                local randomYOffset = (_SilentAim["Y_Offset"] - (math.random() - 0.5) * randomnessFactor)
                
                if ASSettings["Prediction"] == true then
                    _SilentAim["X_Offset"] = randomXOffset * 1.7;
                    _SilentAim["Y_Offset"] = randomYOffset;
                else
                    _SilentAim["X_Offset"] = 0;
                    _SilentAim["Y_Offset"] = 0
                end
                
                _SilentAim["Silent_Target"] = Head;
                local targetPos = Camera:WorldToViewportPoint(Head.Position)
                Line.To = Vector2.new(targetPos.X, targetPos.Y);
                Line.Visible = true
                Txt.Text = math.floor(GetDistance(Head.Position)).." Studs"
            end
        else
            _SilentAim["Silent_Target"] = nil;
            Line.Visible = false;
            Txt.Text = "0 Studs"
        end
    else
        _SilentAim["Silent_Target"] = nil;
        Line.Visible = false;
        Txt.Text = "0 Studs"
    end
end)

task.spawn(function()
    while task.wait() do
        hue = (hue + 1) % 360
        local rainbowColor = Color3.fromHSV(hue / 360, 1, 1)
        Circle.Color = rainbowColor;Line.Color = rainbowColor;Txt.Color = rainbowColor
    end
end)
